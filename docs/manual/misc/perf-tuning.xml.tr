<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE manualpage SYSTEM "../style/manualpage.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.tr.xsl"?>
<!-- English Revision: 805049 -->
<!-- =====================================================
 Translated by: Nilgün Belma Bugüner <nilgun belgeler.org>
   Reviewed by: Orhan Berent <berent belgeler.org>
========================================================== -->

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<manualpage metafile="perf-tuning.xml.meta">
  <parentdocument href="./">Çeşitli Belgeler</parentdocument>

  <title>Apache’de Başarımın Arttırılması</title>

  <summary>

    <p>Apache 2.x, esneklik, taşınabilirlik ve başarım arasında bir denge
      sağlamak üzere tasarlanmış genel amaçlı bir HTTP sunucusudur. Başka
      sunucularla kıyaslama denemelerinde öne geçmek üzere tasarlanmamış
      olsa da Apache 2.x gerçek yaşamda karşılaşılan pek çok durumda oldukça
      yüksek bir başarıma ulaşacak yetenektedir.</p>

    <p>Apache 1.3 ile karşılaştırıldığında 2.x sürümleri toplam veri hızını
      ve ölçeklenebilirliği arttırmak için pek çok en iyileme seçeneği
      içerir. Bu iyileştirmelerin pek çoğu zaten öntanımlı olarak etkin
      olmakla birlikte derleme ve kullanım sırasında başarımı önemli ölçüde
      etkileyebilen yapılandırma seçenekleri de mevcuttur. Bu belgede, bir
      Apache 2.x kurulumunda sunucu yöneticisinin sunucunun başarımını
      arttırmak amacıyla yapılandırma sırasında neler yapabileceğinden
      bahsedilmiştir. Bu yapılandırma seçeneklerinden bazıları, httpd’nin
      donanımın ve işletim sisteminin olanaklarından daha iyi
      yararlanabilmesini sağlarken bir kısmı da  daha hızlı bir sunum için
      yöneticinin işlevsellikten ödün verebilmesini olanaklı kılar.</p>

  </summary>

  <section id="hardware">

    <title>Donanım ve İşletim Sistemi ile İlgili Konular</title>

    <p>HTTP sunucusunun başarımını etkileyen en önemli donanım bellektir
      (RAM). Bir HTTP sunucusu asla takaslama yapmamalıdır. Çünkü takaslama,
      kullanıcının "yeterince hız" umduğu noktada sunumun gecikmesine sebep
      olur. Böyle bir durumda kullanıcılar yüklemeyi durdurup tekrar
      başlatma eğilimindedirler; sonuçta yük daha da artar. <directive
      module="mpm_common" >MaxClients</directive> yönergesinin değerini
      değiştirerek takaslamaya sebep olabilecek kadar çok çocuk süreç
      oluşturulmasını engelleyebilirsiniz ve böyle bir durumda bunu mutlaka
      yapmalısınız. Bunun için yapacağınız işlem basittir: <code>top</code>
      benzeri bir araç üzerinden çalışan süreçlerinizin bir listesini alıp
      Apache süreçlerinizin ortalama büyüklüğünü saptayıp, mevcut bellekten
      bir kısmını diğer süreçler için ayırdıktan sonra kalan miktarı bu
      değere bölerseniz yönergeye atayacağınız değeri bulmuş olursunuz.</p>

    <p>Donanımın diğer unsurları için kararı siz verin: Daha hızlı işlemci,
      daha hızlı ağ kartı, daha hızlı disk; daha hızlının ne kadar hızlı
      olacağını deneyimlerinize bağlı olarak tamamen sizin ihtiyaçlarınız
      belirler.</p>

    <p>İşletim sistemi seçimi büyük oranda yerel ilgi konusudur. Fakat yine
      de, genelde yararlılığı kanıtlanmış bazı kurallar bu seçimde size
      yardımcı olabilir:</p>

    <ul>
      <li>
        <p>Seçtiğiniz işletim sisteminin (çekirdeğin) en son kararlı
          sürümünü çalıştırın. Bir çok işletim sistemi, son yıllarda TCP
          yığıtları ve evre kütüphaneleri ile ilgili belirgin iyileştirmeler
          yapmışlar ve yapmaktadırlar.</p>
      </li>

      <li>
        <p>İşletim sisteminiz <code>sendfile</code>(2) sistem çağrısını
          destekliyorsa bunun etkinleştirilebildiği sürümün kurulu olması
          önemlidir. (Örneğin, Linux için bu, Linux 2.4 ve sonraki sürümler
          anlamına gelirken, Solaris için Solaris 8’den önceki sürümlerin
          yamanması gerektirdiği anlamına gelmektedir.)
          <code>sendfile</code> işlevinin desteklendiği sistemlerde Apache 2
          duruk içeriği daha hızlı teslim etmek ve işlemci kullanımını
          düşürmek amacıyla bu işlevselliği kullanacaktır.</p>
      </li>
    </ul>

  </section>

  <section id="runtime">

    <title>Çalışma Anı Yapılandırması ile İlgili Konular</title>

    <related>
      <modulelist>
        <module>mod_dir</module>
        <module>mpm_common</module>
        <module>mod_status</module>
      </modulelist>
      <directivelist>
        <directive module="core">AllowOverride</directive>
        <directive module="mod_dir">DirectoryIndex</directive>
        <directive module="core">HostnameLookups</directive>
        <directive module="core">EnableMMAP</directive>
        <directive module="core">EnableSendfile</directive>
        <directive module="core">KeepAliveTimeout</directive>
        <directive module="prefork">MaxSpareServers</directive>
        <directive module="prefork">MinSpareServers</directive>
        <directive module="core">Options</directive>
        <directive module="mpm_common">StartServers</directive>
      </directivelist>
    </related>

    <section id="dns">

      <title><code>HostnameLookups</code> ve DNS ile ilgili diğer konular</title>

      <p>Apache 1.3 öncesinde, <directive module="core"
        >HostnameLookups</directive> yönergesinin öntanımlı değeri
        <code>On</code> idi. İstek yerine getirilmeden önce bir DNS sorgusu
        yapılmasını gerektirmesi sebebiyle bu ayarlama her istekte bir
        miktar gecikmeye sebep olurdu. Apache 1.3’ten itibaren yönergenin
        öntanımlı değeri <code>Off</code> yapılmıştır. Eğer günlük
        dosyalarınızda konak isimlerinin bulunmasını isterseniz, Apache ile
        birlikte gelen <program>logresolve</program> programını
        kullanabileceğiniz gibi günlük raporlarını çözümleyen Apache ile
        gelmeyen programlardan herhangi birini de kullanabilirsiniz.</p>

      <p>Günlük dosyaları üzerindeki bu işlemi sunucu makinesi dışında
        günlük dosyasının bir kopyası üzerinde yapmanızı öneririz. Aksi
        takdirde sunucunuzun başarımı önemli ölçüde etkilenebilir.</p>

      <p><directive module="mod_access_compat">Allow</directive> veya
        <directive module="mod_access_compat">Deny</directive>
        yönergelerinde IP adresi yerine bir konak veya alan ismi
        belirtirseniz, iki DNS sorguluk bir bedel ödersiniz (biri normal,
        diğeri IP taklidine karşı ters DNS sorgusu). Başarımı en iyilemek
        için bu yönergelerde mümkün olduğunca isim yerine IP adreslerini
        kullanınız.</p>

      <p><directive module="core" >HostnameLookups</directive>
        yönergelerinin <code>&lt;Location /server-status&gt;</code> gibi
        bölüm yönergelerinin içinde de yer alabileceğini unutmayın. Bu gibi
        durumlarda DNS sorguları sadece istek kuralla eşleştiği takdirde
        yapılacaktır. Aşağıdaki örnekte <code>.html</code> ve
        <code>.cgi</code> dosyalarına yapılan istekler hariç DNS sorguları
        iptal edilmektedir:</p>

      <example>
        HostnameLookups off<br />
        &lt;Files ~ "\.(html|cgi)$"&gt;<br />
        <indent>
          HostnameLookups on<br />
        </indent>
        &lt;/Files&gt;
      </example>

      <p>Yine de bazı CGI’lerin DNS isimlerine ihtiyacı olursa bu CGI’lerin
        bu ihtiyaçlarına yönelik olarak <code>gethostbyname</code> çağrıları
        yapabileceğini gözardı etmeyiniz.</p>

    </section>

    <section id="symlinks">

      <title><code>FollowSymLinks</code> ve
        <code>SymLinksIfOwnerMatch</code></title>

      <p>URL uzayınızda geçerli olmak üzere bir <code>Options
        FollowSymLinks</code> yoksa veya <code>Options
        SymLinksIfOwnerMatch</code> yönergeleri varsa, Apache her sembolik
        bağın üzerinde bazı sınamalar yapmak için ek bir sistem çağrısından
        başka istenen her dosya için de ayrı bir çağrı yapacaktır.</p>

      <example><title>Örnek:</title>
        DocumentRoot /siteler/htdocs<br />
        &lt;Directory /&gt;<br />
        <indent>
          Options SymLinksIfOwnerMatch<br />
        </indent>
        &lt;/Directory&gt;
      </example>

      <p>Bu durumda <code>/index.html</code> için bir istek yapıldığında
        Apache, <code>/siteler</code>, <code>/siteler/htdocs</code> ve<br />
        <code>/siteler/htdocs/index.html</code> üzerinde
        <code>lstat</code>(2) çağrıları yapacaktır. <code>lstat</code>
        sonuçları önbelleğe kaydedilmediğinden bu işlem her istekte
        yinelenecektir. Amacınız gerçekten sembolik bağları güvenlik
        açısından sınamaksa bunu şöyle yapabilirsiniz:</p>

      <example>
        DocumentRoot /siteler/htdocs<br />
        &lt;Directory /&gt;<br />
        <indent>
          Options FollowSymLinks<br />
        </indent>
        &lt;/Directory&gt;<br />
        <br />
        &lt;Directory /sitem/htdocs&gt;<br />
        <indent>
          Options -FollowSymLinks +SymLinksIfOwnerMatch<br />
        </indent>
        &lt;/Directory&gt;
      </example>

      <p>Böylece <directive module="core">DocumentRoot</directive> altındaki
        dosyalar için fazladan bir çağrı yapılmasını engellemiş olursunuz.
        Eğer bazı bölümlerde <directive module="mod_alias"
        >Alias</directive>, <directive module="mod_rewrite"
        >RewriteRule</directive> gibi yönergeler üzerinden belge kök
        dizininizin dışında kalan dosya yollarına sahipseniz benzer
        işlemleri onlar için de yapmalısınız. Sembolik bağ koruması yapmamak
        suretiyle başarımı arttırmak isterseniz, <code>FollowSymLinks</code>
        seçeneğini her yerde etkin kılın ve
        <code>SymLinksIfOwnerMatch</code> seçeneğini asla
        etkinleştirmeyin.</p>

    </section>

    <section id="htacess">

      <title><code>AllowOverride</code></title>

      <p>Genellikle <code>.htaccess</code> dosyaları üzerinden yapıldığı
        gibi URL uzayınızda geçersizleştirmelere izin veriyorsanız, Apache
        her dosya bileşeni için bu <code>.htaccess</code> dosyalarını açmaya
        çalışacaktır.</p>

      <example><title>Örnek:</title>
        DocumentRoot /siteler/htdocs<br />
        &lt;Directory /&gt;<br />
        <indent>
          AllowOverride all<br />
        </indent>
        &lt;/Directory&gt;
      </example>

      <p>Bu durumda <code>/index.html</code> sayfasına yapılan bir istek için
        Apache, <code>/.htaccess</code>, <code>/siteler/.htaccess</code> ve
        <code>/siteler/htdocs/.htaccess</code> dosyalarını açmaya
        çalışacaktır. Çözüm <code>Options FollowSymLinks</code> durumunun
        benzeridir; başarımı arttırmak için dosya sisteminizin her yerinde
        <code>AllowOverride None</code> olsun.</p>

    </section>

    <section id="negotiation">

      <title>Dil Uzlaşımı</title>

      <p>Başarımı son kırıntısına kadar arttırmak istiyorsanız, mümkünse
        içerik dili uzlaşımı da yapmayın. Dil uzlaşımından yararlanmak
        isterken büyük başarım kayıplarına uğrayabilirsiniz. Böyle bir
        durumda sunucunun başarımını arttırmanın tek bir yolu vardır. </p>

      <example>
        DirectoryIndex index
      </example>

      <p>Yukarıdaki gibi bir dosya ismi kalıbı kullanmak yerine, aşağıdaki
        gibi seçenekleri tam bir liste halinde belirtin:</p>

      <example>
        DirectoryIndex index.cgi index.pl index.shtml index.html
      </example>

      <p>Buradaki sıralama öncelik sırasını belirler; yani,
        öncelikli olmasını istediğiniz seçeneği listenin başına
        yazmalısınız.</p>

      <p>İstenen dosya için <code>MultiViews</code> kullanarak dizini
        taratmak yerine, gerekli bilgiyi tek bir dosyadan okutmak suretiyle
        başarımı arttırabilirsiniz. Bu amaçla türeşlem
        (<code>type-map</code>) dosyaları kullanmanız yeterli olacaktır.</p>

      <p>Sitenizde içerik dili uzlaşımına gerek varsa, bunu <code>Options
        MultiViews</code> yönergesi üzerinden değil, türeşlem dosyaları
        kullanarak yapmayı deneyin. İçerik dili uzlaşımı ve türeşlem
        dosyalarının oluşturulması hakkında daha ayrıntılı bilgi edinmek
        için <a href="../content-negotiation.html">İçerik Uzlaşımı</a>
        belgesine bakınız.</p>

    </section>

    <section>

      <title>Bellek Eşlemleri</title>

      <p>Apache’nin SSI sayfalarında olduğu gibi teslim edilecek dosyanın
        içeriğine bakma gereği duyduğu durumlarda, eğer işletim sistemi
        <code>mmap</code>(2) ve benzerlerini destekliyorsa çekirdek normal
        olarak dosyayı belleğe kopyalayacaktır.</p>

      <p>Bazı platformlarda bu belleğe eşleme işlemi başarımı arttırsa da
        başarımın veya httpd kararlılığının zora girdiği durumlar
        olabilmektedir:</p>

      <ul>
        <li>
          <p>Bazı işletim sistemlerinde işlemci sayısı artışına bağlı
            olarak, <code>mmap</code> işlevi <code>read</code>(2) kadar iyi
            ölçeklenmemiştir. Örneğin, çok işlemcili Solaris sunucularda
            <code>mmap</code> iptal edildiği takdirde içeriği sunucu
            tarafından işlenen dosyalar üzerinde bazen daha hızlı işlem
            yapılabilmektedir.</p>
        </li>

        <li>
          <p>Belleğe kopyalanacak dosya NFS üzerinden bağlanan bir dosya
            sistemindeyse ve dosya başka bir NFS istemcisi makine tarafından
            silinmiş veya dosyanın boyutu değiştirilmişse sunucunuz dosyaya
            tekrar erişmeye çalıştığında bir hata alabilecektir.</p>
        </li>
      </ul>

      <p>Böyle durumların olasılık dahilinde olduğu kurulumlarda içeriği
        sunucu tarafından işlenecek dosyaların belleğe kopyalanmaması için
        yapılandırmanıza <code>EnableMMAP off</code> satırını ekleyiniz.
        (Dikkat: Bu yönerge dizin seviyesinde geçersizleştirilebilen
        yönergelerdendir.)</p>

    </section>

    <section>

      <title><code>sendfile</code></title>

      <p>Apache’nin duruk dosyalarda olduğu gibi teslim edilecek dosyanın
        içeriğine bakmadığı durumlarda, eğer işletim sistemi
        <code>sendfile</code>(2) desteğine sahipse çekirdek normal olarak bu
        desteği kullanacaktır.</p>

      <p>Bazı platformlarda <code>sendfile</code> kullanımı, okuma ve yazma
        işlemlerinin ayrı ayrı yapılmamasını sağlasa da
        <code>sendfile</code> kullanımının httpd kararlılığını bozduğu bazı
        durumlar sözkonusudur:</p>

      <ul>
        <li>
          <p>Bazı platformlar derleme sisteminin saptayamadığı bozuk bir
            <code>sendfile</code> desteğine sahip olabilir. Özellikle
            derleme işleminin başka bir platformda yapılıp
            <code>sendfile</code> desteği bozuk bir makineye kurulum
            yapıldığı durumlarda bu desteğin bozuk olduğu
            saptanamayacaktır.</p>
        </li>
        <li>
          <p>Çekirdek, NFS üzerinden erişilen ağ dosyalarını kendi önbelleği
            üzerinden gerektiği gibi sunamayabilir.</p>
        </li>
      </ul>

      <p>Böyle durumların olasılık dahilinde olduğu kurulumlarda içeriğin
        <code>sendfile</code> desteğiyle teslim edilmemesi için
        yapılandırmanıza <code>EnableSendfile off</code> satırını ekleyiniz.
        (Dikkat: Bu yönerge dizin seviyesinde geçersizleştirilebilen
        yönergelerdendir.)</p>

    </section>

    <section id="process">

      <title>Süreç Oluşturma</title>

      <p>Apache 1.3 öncesinde <directive module="prefork"
        >MinSpareServers</directive>, <directive module="prefork"
        >MaxSpareServers</directive> ve <directive module="mpm_common"
        >StartServers</directive> ayarları, başka sunucularla kıyaslama
        denemelerinde olağanüstü kötü sonuçlar alınmasına sebep olmaktaydı.
        Özellikle uygulanan yükü karşılamaya yetecek sayıda çocuk süreç
        oluşturulması aşamasında Apache’nin elde ettiği ivme bunlardan
        biriydi. Başlangıçta <directive module="mpm_common"
        >StartServers</directive> yönergesiyle belli sayıda süreç
        oluşturulduktan sonra her saniyede bir tane olmak üzere <directive
        module="prefork">MinSpareServers</directive> sayıda çocuk süreç
        oluşturulmaktaydı. Örneğin, aynı anda 100 isteğe yanıt vermek için
        <directive module="mpm_common" >StartServers</directive>
        yönergesinin öntanımlı değeri olarak başta <code>5</code> süreç
        oluşturulduğundan kalan süreçler için 95 saniye geçmesi gerekirdi.
        Sık sık yeniden başlatılmadıklarından dolayı gerçek hayatta
        sunucuların başına gelen de buydu. Başka sunucularla kıyaslama
        denemelerinde ise işlem sadece on dakika sürmekte ve içler acısı
        sonuçlar alınmaktaydı.</p>

      <p>Saniyede bir kuralı, sunucunun yeni çocukları oluşturması sırasında
        sistemin aşırı meşgul duruma düşmemesi için alınmış bir önlemdi.
        Makine çocuk süreç oluşturmakla meşgul edildiği sürece isteklere
        yanıt veremeyecektir. Böylesi bir durum Apache’nin başarımını
        kötüleştirmekten başka işe yaramayacaktır. Apache 1.3’te saniyede
        bir kuralı biraz esnetildi. Yeni gerçeklenimde artık bir süreç
        oluşturduktan bir saniye sonra iki süreç, bir saniye sonra dört
        süreç oluşturulmakta ve işlem, saniyede 32 çocuk süreç oluşturulur
        duruma gelene kadar böyle ivmelenmektedir. Çocuk süreç oluşturma
        işlemi <directive module="prefork" >MinSpareServers</directive>
        değerine ulaşılınca durmaktadır.</p>

      <p>Bu, <directive module="prefork" >MinSpareServers</directive>,
        <directive module="prefork" >MaxSpareServers</directive> ve
        <directive module="mpm_common" >StartServers</directive> ayarlarıyla
        oynamayı neredeyse gereksiz kılacak kadar iyi sonuçlar verecek gibi
        görünmektedir. Saniyede 4 çocuktan fazlası oluşturulmaya
        başlandığında hata günlüğüne bazı iletiler düşmeye başlar. Bu
        iletilerin sayısı çok artarsa bu ayarlarla oynama vakti gelmiş
        demektir. Bunun için <module>mod_status</module> çıktısını bir
        kılavuz olarak kullanabilirsiniz.</p>

      <p>Süreç oluşturmayla ilgili olarak süreç ölümü <directive
        module="mpm_common">MaxRequestsPerChild</directive> değeri ile
        sağlanır. Bu değer öntanımlı olarak <code>0</code> olup, çocuk süreç
        başına istek sayısının sınırsız olduğu anlamına gelir. Eğer
        yapılandırmanızda bu değeri <code>30</code> gibi çok düşük bir
        değere ayarlarsanız bunu hemen kaldırmak zorunda kalabilirsiniz.
        Sunucunuzu SunOS veya Solaris’in eski bir sürümü üzerinde
        çalıştırıyorsanız bellek kaçaklarına sebep olmamak için bu değeri
        <code>10000</code> ile sınırlayınız.</p>

      <p>Kalıcı bağlantı özelliğini kullanıyorsanız, çocuk süreçler zaten
        açık bağlantılardan istek beklemekte olacaklardır. <directive
        module="core">KeepAliveTimeout</directive> yönergesinin öntanımlı
        değeri <code>5</code> saniye olup bu etkiyi en aza indirmeye yönelik
        süredir. Burada ağ band genişliği ile sunucu kaynaklarının kullanımı
        arasında bir seçim yapmak söz konusudur. Hiçbir şey umurunuzda
        değilse <a
        href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-4.html">
        çoğu ayrıcalığın yitirilmesi pahasına</a> bu değeri rahatça
        <code>60</code> saniyenin üzerine çıkarabilirsiniz.</p>

    </section>
  </section>

  <section id="compiletime">
    <title>Derleme Sırasında Yapılandırma ile İlgili Konular</title>

    <section>
      <title>MPM Seçimi</title>

      <p>Apache 2.x, <a href="../mpm.html">Çok Süreçlilik Modülleri</a>
        (MPM) adı verilen eklemlenebilir çok görevlilik modellerini
        destekler. Apache’yi derlerken bu MPM’lerden birini seçmeniz
        gerekir. MPM’lerden bazıları platformlara özeldir:
        <module>mpm_netware</module>, <module>mpmt_os2</module> ve
        <module>mpm_winnt</module>. Unix
        benzeri sistemler için ise seçebileceğiniz modül sayısı birden
        fazladır. MPM seçiminin httpd’nin hızında ve ölçeklenebilirliğinde
        bazı etkileri olabilir:</p>

      <ul>

        <li><module>worker</module> modülü her biri çok evreli çok sayıda
          çocuk süreç kullanımını destekler. Her evre aynı anda tek bir
          bağlantıya hizmet sunar. Aynı hizmeti daha az bellek harcayarak
          vermesi nedeniyle yüksek trafiğe sahip sunucularda
          <module>prefork</module> modülüne göre daha iyi bir seçimdir.</li>

        <li><module>prefork</module> modülü her biri tek bir evreye sahip
          çok sayıda çocuk süreç kullanımını destekler. Her süreç aynı anda
          tek bir bağlantıya hizmet sunar. Çoğu sistemde daha hızlı olması
          nedeniyle <module>worker</module> modülüne göre daha iyi bir seçim
          olarak görünürse de bunu daha fazla bellek kullanarak sağlar.
          <module>prefork</module> modülünün evresiz tasarımının
          <module>worker</module> modülüne göre bazı yararlı tarafları
          vardır: Çok evreli sistemlerde güvenilir olmayan üçüncü parti
          modülleri kullanabilir ve evrelerde hata ayıklamanın yetersiz
          kaldığı platformlarda hatalarını ayıklamak daha kolaydır.</li>

      </ul>

      <p>Bu modüller ve diğerleri hakkında daha ayrıntılı bilgi edinmek için
        <a href="../mpm.html">Çok Süreçlilik Modülleri</a> belgesine
        bakınız.</p>

    </section>

    <section id="modules">

        <title>Modüller</title>

        <p>Bellek kullanımı başarım konusunda önemli olduğundan gerçekte
        kullanmadığınız modülleri elemeye çalışmalısınız. Modülleri birer <a
        href="../dso.html">DSO</a> olarak derlediyseniz <directive
        module="mod_so">LoadModule</directive> yönergesinin bulunduğu satırı
        açıklama haline getirmeniz modülden kurtulmanız için yeterli
        olacaktır. Modülleri bu şekilde kaldırarak onların yokluğunda
        sitenizin hala işlevlerini yerine getirdiğini görme şansına da
        kavuşmuş olursunuz.</p>

        <p>Ancak, eğer modülleri Apache çalıştırılabilirinin içine
        gömmüşseniz istenmeyen modülleri kaldırmak için Apache'yi yeniden
        derlemeniz gerekir.</p>

        <p>Bu noktada bir soru akla gelebilir: Hangi modüller gerekli,
        hangileri değil? Bu sorunun yanıtı şüphesiz siteden siteye değişir.
        Ancak, olmazsa olmaz moüller olarak <module>mod_mime</module>,
        <module>mod_dir</module> ve <module>mod_log_config</module>
        modüllerini sayabiliriz. Bunlardan <code>mod_log_config</code>
        olmadan da bir sitenin çalışabileceğinden hareketle bu modülün
        varlığı isteğe bağlı olsa da bu modülü kaldırmanızı önermiyoruz.</p>

    </section>

    <section>

      <title>Atomik İşlemler</title>

      <p>Worker MPM'nin en son geliştirme sürümleri ve
      <module>mod_cache</module> gibi bazı modüller APR'nin atomik API'sini
      kullanırlar. Bu API, düşük ayarlı evre eşzamanlamasında atomik
      işlemler yapar.</p>

      <p>Öntanımlı olarak, APR bu işlemleri hedef işletim sistemi/işlemci
      platformunda kullanılabilecek en verimli mekanizmayı kullanarak
      gerçekleştirir. Günümüz işlemcilerinin çoğu, örneğin, bir atomik
      karşılaştırma ve takas (CAS) işlemini donanımda gerçekleştirmektedir.
      Bazı platformlarda APR'nin atomik işlemler için öntanımlı olarak daha
      yavaş olan mutekslere dayalı gerçeklenimi kullanmasının sebebi eski
      işlemcilerde bu tür makine kodlarının yokluğudur. Apache'yi bu tür
      platformalarda günümüz işlemcileriyde çalıştırmayı düşünüyorsanız
      Apache'yi derlemek için yapılandırırken en hızlı atomik işlemin
      seçilebilmesi için <code>--enable-nonportable-atomics</code>
      seçeneğini kullanın:</p>

      <example>
        ./buildconf<br />
        ./configure --with-mpm=worker --enable-nonportable-atomics=yes
      </example>

      <p><code>--enable-nonportable-atomics</code> seçeneği şu platformlar
      için uygundur:</p>

      <ul>

        <li>SPARC üzerinde Solaris<br />
            APR öntanımlı olarak, SPARC/Solaris üzerinde mutekslere dayalı
            atomik işlemleri kullanır. Ancak,
            <code>--enable-nonportable-atomics</code> yapılandırmasını
            kullanırsanız, donanım üzerinde hızlı karşılaştırma ve takas
            için uygun SPARC v8plus kodunu kullanacak şekilde kod üretilir.
            Apache'yi bu seçenekle yapılandırırsanız atomik işlemler daha
            verimli olacak fakat derlenen Apache çalıştırılabiliri sadece
            UltraSPARC kırmığı üzerinde çalışacaktır.
        </li>

        <li>x86 üzerinde Linux<br />
            APR öntanımlı olarak, Linux üzerinde mutekslere dayalı atomik
            işlemleri kullanır. Ancak,
            <code>--enable-nonportable-atomics</code> yapılandırmasını
            kullanırsanız, donanım üzerinde hızlı karşılaştırma ve takas
            için uygun 486 kodunu kullanacak şekilde kod üretilir. Apache'yi
            bu seçenekle yapılandırırsanız atomik işlemler daha verimli
            olacak fakat derlenen Apache çalıştırılabiliri (386 üzerinde
            değil) sadece 486 ve sonrası kırmıklarda çalışacaktır.
        </li>

      </ul>

    </section>

    <section>

      <title><code>mod_status</code> ve <code>ExtendedStatus On</code>
      </title>

      <p><module>mod_status</module> modülünü derlemiş ve Apache'yi
      yapılandırır ve çalıştırırken <code>ExtendedStatus On</code> satırını
      da kullanmışsanız Apache her istek üzerinde
      <code>gettimeofday(2)</code> (veya işletim sistemine bağlı olarak
      <code>time(2)</code>) çağrısından başka (1.3 öncesinde) fazladan
      defalarca  <code>time(2)</code> çağrıları yapacaktır. Bu çağrılarla
      durum raporununun zamanlama bilgilerini içermesi sağlanır. Başarımı
      arttırmak için <code>ExtendedStatus off</code> yapın (zaten öntanımlı
      böyledir).</p>

    </section>

    <section>

      <title><code>accept</code> dizgilemesi ve çok soketli işlem</title>

    <note type="warning"><title>Uyarı:</title>
      <p>Bu bölüm, Apache HTTP sunucusunun 2.x sürümlerinde yapılan
      değişikliklere göre tamamen güncellenmemiştir. Bazı bilgiler hala
      geçerliyse de lütfen dikkatli kullanınız.</p>
    </note>

      <p>Burada Unix soket arayüzü gerçeklenirken ihmal edilen bir durumdan
      bahsedeceğiz. HTTP sunucunuzun çok sayıda adresten çok sayıda portu
      dinlemek için çok sayıda <directive module="mpm_common"
      >Listen</directive> yönergesi kullanmakta olduğunu varsayalım. Her
      soketi çalıştığını görmek için denerken Apache bağlantı için
      <code>select(2)</code> kullanacaktır. <code>select(2)</code> çağrısı
      bu soketin üzerinde <em>sıfır</em> veya <em>en azından bir</em>
      bağlantının beklemekte olduğu anlamına gelir. Apache'nin modeli çok
      sayıda çocuk süreç içerir ve boşta olanların tümünde aynı anda yeni
      bağlantılar denenebilir. Gerçekte çalışan kod bu olmasa da meramımızı
      anlatmak için kodun şöyle bir şey olduğunu varsayabiliriz:</p>

      <example>
        for (;;) {<br />
        <indent>
          for (;;) {<br />
          <indent>
            fd_set accept_fds;<br />
            <br />
            FD_ZERO (&amp;accept_fds);<br />
            for (i = first_socket; i &lt;= last_socket; ++i) {<br />
            <indent>
              FD_SET (i, &amp;accept_fds);<br />
            </indent>
            }<br />
            rc = select (last_socket+1, &amp;accept_fds, NULL, NULL, NULL);<br />
            if (rc &lt; 1) continue;<br />
            new_connection = -1;<br />
            for (i = first_socket; i &lt;= last_socket; ++i) {<br />
            <indent>
              if (FD_ISSET (i, &amp;accept_fds)) {<br />
              <indent>
                new_connection = accept (i, NULL, NULL);<br />
                if (new_connection != -1) break;<br />
              </indent>
              }<br />
            </indent>
            }<br />
            if (new_connection != -1) break;<br />
          </indent>
          }<br />
          process the new_connection;<br />
        </indent>
        }
      </example>

      <p>Bu özet gerçeklenim bir takım açlık sorunlarına sebep olur. Bu
      döngünün çalışması sırasında aynı anda çok sayıda çocuk süreç yeniden
      çağrılır ve istekler arasında kalan çoğu çocuk da <code>select</code>
      ile engellenir. Engellenen tüm bu çocuklar soketlerden herhangi biri
      üzerinde tek bir istek göründüğünde <code>select</code> tarafından
      uyandırılıp işleme sokulmak üzere döndürülürler (uyandırılan çocuk
      sayısı işletim sistemine ve zamanlama ayarlarına göre değişiklik
      gösterir). Bunların hepsi döngüye katılıp bağlantı kabul etmeye
      (<code>accept</code>) çalışırlar. Fakat içlerinden yalnız biri
      (sadece bir bağlantı isteğinin mevcut olduğu varsayımıyla) bunu
      başarabilir. Kalanının bağlantı kabul etmesi (<code>accept</code>)
      engellenir. Bu durum, bu çocukları istekleri başka başka soketlerden
      değil mecburen tek bir soketten kabul etmeye kilitler ve bu soket
      üzerinde yeni bir istek belirip uyandırılana kadar bu durumda
      kalırlar. Bu açlık sorunu ilk olarak <a
      href="http://bugs.apache.org/index/full/467">PR#467</a> sayılı raporla
      belgelenmiştir. Bu sorunun en az iki çözümü vardır.</p>

      <p>Çözümün biri engellenmeyen soket kullanımıdır. Bu durumda
      <code>accept</code> çocukları engellemeyecek ve yapılan bir
      bağlantının ardından diğer çocuklar durumları değişmeksizin bağlantı
      beklemeye devam edeceklerdir. Fakat bu durum işlemci zamanının boşa
      harcanmasına sebep olur.  Seçilmiş (<code>select</code>) boşta on
      çocuğun olduğunu ve bir bağlantı geldiğini varsayalım. Kalan dokuz
      çocuk işine devam edip bağlantı kabul etmeyi (<code>accept</code>)
      deneyecek, başarızsız olacak, dönecek başa, tekrar seçilecek
      (<code>select</code>) ve böyle hiçbir iş yapmadan dönüp duracaktır. Bu
      arada hizmet sunmakta olanlar da işlerini bitirdikten sonra bu
      döngüdeki yerlerini alacaklardır. Aynı kutunun içinde boşta bir sürü
      işlemciniz (çok işlemcili sistemler) yoksa bu çözüm pek verimli
      olmayacaktır.</p>

      <p>Diğer çözüm ise Apache tarafından kullanılan çözüm olup, girdiyi
      bir iç döngüde sıraya sokmaktır. Döngü aşağıda örneklenmiştir (farklar
      vurgulanmıştır):</p>

      <example>
        for (;;) {<br />
        <indent>
          <strong>accept_mutex_on ();</strong><br />
          for (;;) {<br />
          <indent>
            fd_set accept_fds;<br />
            <br />
            FD_ZERO (&amp;accept_fds);<br />
            for (i = first_socket; i &lt;= last_socket; ++i) {<br />
            <indent>
              FD_SET (i, &amp;accept_fds);<br />
            </indent>
            }<br />
            rc = select (last_socket+1, &amp;accept_fds, NULL, NULL, NULL);<br />
            if (rc &lt; 1) continue;<br />
            new_connection = -1;<br />
            for (i = first_socket; i &lt;= last_socket; ++i) {<br />
            <indent>
              if (FD_ISSET (i, &amp;accept_fds)) {<br />
              <indent>
                new_connection = accept (i, NULL, NULL);<br />
                if (new_connection != -1) break;<br />
              </indent>
              }<br />
            </indent>
            }<br />
            if (new_connection != -1) break;<br />
          </indent>
          }<br />
          <strong>accept_mutex_off ();</strong><br />
          process the new_connection;<br />
        </indent>
        }
      </example>

      <p><code>accept_mutex_on</code> ve <code>accept_mutex_off</code> <a
      id="serialize" name="serialize">işlevleri</a> bir karşılıklı red
      semoforu oluştururlar. Mutekse aynı anda sadece bir çocuk sahip
      olabilir. Bu muteksleri gerçeklemek için çeşitli seçenekler vardır.
      Seçim, <code>src/conf.h</code> (1.3 öncesi) veya
      <code>src/include/ap_config.h</code> (1.3 ve sonrası) dosyasında
      tanımlanmıştır. Bazı mimariler bir kilitleme seçeneğine sahip
      değildir. Böyle mimarilerde çok sayıda <directive
      module="mpm_common">Listen</directive> yönergesi kullanmak güvenilir
      olmayacaktır.</p>

      <p><directive module="mpm_common">AcceptMutex</directive> yönergesi,
      seçilen muteks gerçeklenimini çalışma anında değiştirmek için
      kullanılabilir.</p>

      <dl>
        <dt><code>AcceptMutex flock</code></dt>

        <dd>
          <p>Bu yöntem, bir kilit dosyasını kilitlemek için
          <code>flock(2)</code> sistem çağrısını kullanır (Kilit dosyasının
          yeri <directive module="mpm_common" >LockFile</directive>
          yönergesiyle belirtilir).</p>
        </dd>

        <dt><code>AcceptMutex fcntl</code></dt>

        <dd>
          <p>Bu yöntem, bir kilit dosyasını kilitlemek için
          <code>fcntl(2)</code> sistem çağrısını kullanır (Kilit dosyasının
          yeri <directive module="mpm_common" >LockFile</directive>
          yönergesiyle belirtilir).</p>
        </dd>

        <dt><code>AcceptMutex sysvsem</code></dt>

        <dd>
          <p>(1.3 ve sonrası) Bu yöntem muteksi gerçeklemek için SysV tarzı
          semaforları kullanır. Maalesef, SysV tarzı semaforların bazı yan
          etkileri vardır. Bunlardan biri Apache'nin semaforu temizlemeden
          ölme ihtimalidir (<code>ipcs(8)</code> kılavuz sayfasına bakınız).
          Diğer biri, CGI'lerin sunucu ile aynı kullanıcı kimliğini
          kullanmaları nedeniyle semafor arayüzünün hizmet reddi
          saldırılarına açık olmasıdır (<program>suexec</program> veya
          <code>cgiwrapper</code> gibi bir şeyler kullanmadıkça bütün
          CGI'ler için söz konusudur).</p>
        </dd>

        <dt><code>AcceptMutex pthread</code></dt>

        <dd>
          <p>(1.3 ve sonrası) Bu yöntem POSIX mutekslerini kullanır ve POSIX
          evreleri belirtiminin tamamen gerçeklendiği mimarilerde çalışması
          gerekirse de sadece Solaris (2.5 ve sonrası) üzerinde ve sadece
          belli yapılandırmalarla çalışmakta gibi görünmektedir. Bunu
          denemişseniz sunucunuzun çöktüğünü ve yanıt vermediğini
          görmüşsünüzdür. Sadece duruk içerikli sunucular iyi
          çalışmaktadır.</p>
        </dd>

        <dt><code>AcceptMutex posixsem</code></dt>

        <dd>
          <p>(2.0 ve sonrası)  Bu yöntem POSIX semaforlarını kullanır. Eğer
          işlem sırasında bir evre muteks kaynaklı parçalama arızalarıyla
          karşı karşıya kalırsa HTTP sunucusunun çökmesiyle semaforun sahibi
          kurtarılamaz.</p>
        </dd>

      </dl>

      <p>Eğer sisteminiz yukarıda bahsedilenler dışında başka bir dizgileme
      yöntemi kullanıyorsa bununla ilgili kodun APR'ye eklenmesi girilen
      zahmete değecektir.</p>

      <p>Başka bir çözüm daha vardır ancak döngü kısmen dizgilenmeyeceğinden
      (yani belli sayıda sürece izin verilemeyeceğinden) asla
      gerçeklenmemiştir. Bu sadece, aynı anda çok sayıda çocuk sürecin
      çalışabileceği ve dolayısıyla band genişliğinin tüm yönleriyle
      kullanılabileceği çok işlemcili sistemlerde ilginç olabilirdi. Bu
      gelecekte incelenmeye değer bir konu olmakla beraber çok sayıda HTTP
      sunucusunun aynı anda aynı amaca hizmet edecek şekilde çalışması
      standart olarak pek mümkün görülmediğinden bu olasılık çok
      düşüktür.</p>

      <p>En yüksek başarımı elde etmek için ideal olanı sunucuları
      çalıştırırken çok sayıda <directive module="mpm_common"
      >Listen</directive> yönergesi kullanmamaktır. Fakat siz yine de
      okumaya devam edin.</p>

    </section>

    <section>

      <title><code>accept</code> dizgilemesi - tek soket</title>

      <p>Çok soketli sunucular için yukarıda açıklananlar iyi güzel de tek
      soketli sunucularda durum ne? Kuramsal olarak, bunların hiçbiriyle bir
      sorunları olmaması gerekir. Çünkü yeni bir bağlantı gelene kadar tüm
      çocuklar <code>accept(2)</code> ile engellenirler dolayısıyla hiçbir
      açlık sorununun ortaya çıkmaması gerekir. Uygulamada ise son
      kullanıcıdan gizli olarak, yukarıda engellenmeyen çocuklar çözümünde
      bahsedilenle hemen hemen aynı "boşa dönüp durma" davranışı mevcuttur.
      Çoğu TCP yığıtı bu yolu gerçeklemiştir. Çekirdek, yeni bir bağlantı
      ortaya çıktığında <code>accept</code> ile engellenen tüm süreçleri
      uyandırır. Bu süreçlerden bağlantıyı alan kullanıcı bölgesine geçerken
      çekirdek içinde döngüde olan diğerleri de yeni bağlantı keşfedilene
      kadar uykularına geri dönerler. Bu çekirdek içi döngü, kullanıcı
      bölgesindeki kodlara görünür değildir ama bu olmadıkları anlamına
      gelmez. Bu durum, çok soketli engellenmeyen çocuklar çözümündeki boşa
      döngünün sebep olduğu gereksiz işlemci yükü sorununu içinde
      barındırır.</p>

      <p>Bununla birlikte, tek soketli durumda bile bundan daha verimli bir
      davranış sergileyen bir çok mimari bulduk. Bu aslında hemen hemen her
      durumda öntanımlı olarak böyledir. Linux altında yapılan üstünkörü
      denemelerde (128MB bellekli çift Pentium pro 166 işlemcili makinede
      Linux 2.0.30) tek sokette dizgilemenin dizgilenmemiş duruma göre
      saniyede %3 daha az istekle sonuçlandığı gösterilmiştir. Fakat
      dizgilenmemiş tek soket durumunda her istekte 100ms'lik ek bir gecikme
      olduğu görülmüştür. Bu gecikmenin sebebi muhtemelen uzun mesafeli
      hatlar olup sadece yerel ağlarda söz konusudur. Tek soketli
      dizgilemeyi geçersiz kılmak için
      <code>SINGLE_LISTEN_UNSERIALIZED_ACCEPT</code> tanımlarsanız tek
      soketli sunucularda artık dizgileme yapılmayacaktır.</p>

    </section>

    <section>

      <title>Kapatmayı zamana yaymak</title>

      <p><a href="http://www.ics.uci.edu/pub/ietf/http/draft-ietf-http-connection-00.txt"
      >draft-ietf-http-connection-00.txt</a> taslağının 8. bölümünde
      bahsedildiği gibi, bir HTTP sunucusunun protokolü <strong>güvenilir
      şekilde</strong> gerçeklemesi için her iki yöndeki iletişimi
      birbirinden bağımsız olarak (iki yönlü bir TCP bağlantısının her
      yarısını diğerinden bağımsız olarak) kapatması gerekir. Bu olgu başka
      sunucular tarafından çoğunlukla dikkate alınmaz fakat Apache'nin 1.2
      sürümünden beri gerektiği gibi gerçeklenmektedir.</p>

      <p>Bu özellik Apache'ye eklendiğinde Unix'in çeşitli sürümlerinde
      uzgörüsüzlükten dolayı bir takım geçici telaş sorunlarına sebep oldu.
      TCP belirtimi <code>FIN_WAIT_2</code> durumunda bir zaman aşımından
      bahsetmez ama yasaklamaz da. Zaman aşımı olmayan sistemlerde, Apache
      1.2 çoğu soketin sonsuza kadar <code>FIN_WAIT_2</code> durumunda
      takılıp kalmasına sebep olur. Çoğu durumda, satıcıdan sağlanan en son
      TCP/IP yamalarını uygulanarak bu önlenebilir. Satıcının hiçbir yeni
      yama dağıtmadığı durumlarda (örneğin, SunOS4 -- bir kaynak lisansı ile
      insanlar bunu kendileri yamayabilirse de) bu özelliği devre dışı
      bırakmaya karar verdik.</p>

      <p>Bunun üstesinden gelmenin iki yolu vardır. Bunlardan biri
      <code>SO_LINGER</code> soket seçeneğidir. Bu işin kaderi buymuş gibi
      görünürse de çoğu TCP/IP yığıtında bu gerektiği gibi
      gerçeklenmemiştir. Bu yığıtlar üzerinde, bu yöntemin, doğru bir
      gerçeklenimle bile (örneğin, Linux 2.0.31) sonraki çözümden daha
      pahalı olduğu ortaya çıkmıştır.</p>

      <p>Çoğunlukla, Apache bunu (<code>http_main.c</code> içindeki)
      <code>lingering_close</code> adında bir işlevle gerçekler. Bu işlev
      kabaca şöyle görünür:</p>

      <example>
        void lingering_close (int s)<br />
        {<br />
        <indent>
          char junk_buffer[2048];<br />
          <br />
          /* gönderen tarafı kapat */<br />
          shutdown (s, 1);<br />
          <br />
          signal (SIGALRM, lingering_death);<br />
          alarm (30);<br />
          <br />
          for (;;) {<br />
          <indent>
            /* s'i okumak için, 2 saniyelik zaman aşımı ile seç */<br />
            select (s for reading, 2 second timeout);<br />
            /* Hata oluşmuşsa döngüden çık */<br />
            if (error) break;<br />
            /* s okumak için hazırsa */<br />
            if (s is ready for reading) {<br />
            <indent>
              if (read (s, junk_buffer, sizeof (junk_buffer)) &lt;= 0) {<br />
              <indent>
                break;<br />
              </indent>
              }<br />
              /* geri kalan herşey burada */<br />
            </indent>
            }<br />
          </indent>
          }<br />
          <br />
          close (s);<br />
        </indent>
        }
      </example>

      <p>Bağlantı sonunda bu doğal olarak biraz daha masrafa yol açar, fakat
      güvenilir bir gerçeklenim için bu gereklidir. HTTP/1.1'in daha yaygın
      kullanılmaya başlanması ve tüm bağlantıların kalıcı hale gelmesiyle bu
      gerçeklenim daha fazla istek üzerinden kendi masrafını
      karşılayacaktır. Ateşle oynamak ve bu özelliği devre dışı bırakmak
      isterseniz <code>NO_LINGCLOSE</code>'u tanımlayabilirsiniz, fakat bu
      asla önerilmez. Özellikle, HTTP/1.1'den itibaren boruhatlı kalıcı
      bağlantıların <code>lingering_close</code> kullanmaya başlaması mutlak
      bir gerekliliktir (ve <a
      href="http://www.w3.org/Protocols/HTTP/Performance/Pipeline.html">
      boruhatlı bağlantıların daha hızlı</a> olması nedeniyle bu
      bağlantıları desteklemek isteyebilirsiniz).</p>

    </section>

    <section>

      <title>Çetele Dosyası</title>

      <p>Apache'nin ana ve alt süreçleri birbirleriyle çetele denen birşey
      üzerinden haberleşirler. Bunun en mükemmel şekilde paylaşımlı bellekte
      gerçeklenmesi gerekir. Eriştiğimiz veya portlarını ayrıntılı olarak
      belirttiğimiz işletim sistemleri için bu, genellikle paylaşımlı bellek
      kullanılarak gerçeklenir. Geri kalanlar, öntanımlı olarak bunu bir
      disk dosyası kullanarak gerçekler. Bir disk dosyaı yavaş olmanın yanı
      sıra güvenilir de değildir (ve daha az özelliğe sahiptir). Mimarinizin
      <code>src/main/conf.h</code> dosyasını inceleyin ve
      <code>USE_MMAP_SCOREBOARD</code> veya
      <code>USE_SHMGET_SCOREBOARD</code>'a bakın. Bu ikisinden birinin (ve
      yanı sıra sırasıyla <code>HAVE_MMAP</code> veya
      <code>HAVE_SHMGET</code>'in) tanımlanmış olması, sağlanan paylaşımlı
      bellek kodunu etkinleştirir. Eğer sisteminiz diğer türdeki paylaşımlı
      belleğe sahipse, <code>src/main/http_main.c</code> dosyasını açıp,
      Apache'de bu belleği kullanması gereken kanca işlevleri ekleyin (Bize
      de bir yama yollayın, lütfen).</p>

      <note>Tarihsel bilgi: Apache'nin Linux uyarlaması, Apache'nin 1.2
      sürümüne kadar paylaşımlı belleği kullanmaya başlamamıştı. Bu kusur,
      Apache'nin Linux üzerindeki erken dönem sürümlerinin davranışlarının
      zayıf ve güvenilmez olmasına yol açmıştı.</note>

    </section>

    <section>

      <title>DYNAMIC_MODULE_LIMIT</title>

      <p>Devingen olarak yüklenen modülleri kullanmamak niyetindeyseniz
      (burayı okuyan ve sunucunuzun başarımını son kırıntısına kadar
      arttırmakla ilgilenen biriyseniz bunu düşünmezsiniz), sunucunuzu
      derlerken seçenekler arasına <code>-DDYNAMIC_MODULE_LIMIT=0</code>
      seçeneğini de ekleyin. Bu suretle, sadece, devingen olarak yüklenen
      modüller için ayrılacak belleği kazanmış olacaksınız.</p>

    </section>

  </section>

  <section id="trace">

    <title>Ek: Bir çağrı izlemesinin ayrıntılı çözümlemesi</title>

    <p>Burada, Solaris 8 üzerinde worker MPM'li Apache 2.0.38'in bir sistem
    çağrısı izlenmektedir. Bu izleme şu komutla elde edilmiştir:</p>

    <example>
      truss -l -p <var>httpd_çocuk_pidi</var>.
    </example>

    <p><code>-l</code> seçeneği, truss'a hafif bir sürecin yaptığı her
    sistem çağrısını (hafif süreç -- HS -- Solaris'in bir çekirdek seviyesi
    evreleme biçimi) günlüğe yazmasını söyler.</p>

    <p>Diğer sistemlerin sistem çağrılarını izleyen farklı araçları vardır
    (<code>strace</code>, <code>ktrace</code>, <code>par</code> gibi).
    Bunlar da benzer çıktılar üretirler.</p>

    <p>Bu izleme sırasında, bir istemci httpd'den 10 KB'lık duruk bir dosya
    talebinde bulunmuştur. Duruk olmayan veya içerik uzlaşımlı isteklerin
    izleme kayıtları vahşice (bazı durumlarda epey çirkince) farklı
    görünür.</p>

    <example>
      /67:    accept(3, 0x00200BEC, 0x00200C0C, 1) (uykuda...)<br />
      /67:    accept(3, 0x00200BEC, 0x00200C0C, 1)            = 9
    </example>

    <p>Bu izlemede, dinleyen evre HS #67 içinde çalışmaktadır.</p>

    <note><code>accept(2)</code> dizgelemesinin olmayışına dikkat edin.
    Özellikle bu platformda worker MPM, çok sayıda portu dinlemedikçe,
    öntanımlı olarak dizgeleştirilmemiş bir accept çağrısı kullanır.</note>

    <example>
      /65:    lwp_park(0x00000000, 0)                         = 0<br />
      /67:    lwp_unpark(65, 1)                               = 0
    </example>

    <p>Bağlantının kabul edilmesiyle, dinleyici evre isteği yerine getirmek
    üzere bir worker evresini uyandırır. Bu izlemede, isteği yerine getiren
    worker evresi  HS #65'e aittir.</p>

    <example>
      /65:    getsockname(9, 0x00200BA4, 0x00200BC4, 1)       = 0
    </example>

    <p>Sanal konakların gerçeklenimi sırasında, Apache'nin, bağlantıları
    kabul etmek için kullanılan yerel soket adreslerini bilmesi gerekir.
    Çoğu durumda bu çağrıyı bertaraf etmek mümkündür (hiç sanal konağın
    olmadığı veya <directive module="mpm_common">Listen</directive>
    yönergelerinin mutlak adreslerle kullanıldığı durumlarda). Fakat bu en
    iyilemeleri yapmak için henüz bir çaba harcanmamıştır.</p>

    <example>
      /65:    brk(0x002170E8)                                 = 0<br />
      /65:    brk(0x002190E8)                                 = 0
    </example>

    <p><code>brk(2)</code> çağrıları devingen bellekten bellek ayırır. httpd
    çoğu isteği yerine getirirken özel bellek ayırıcılar
    (<code>apr_pool</code> ve <code>apr_bucket_alloc</code>) kullandığından
    bunlar bir sistem çağrısı izlemesinde nadiren görünür. Bu izlemede,
    httpd henüz yeni başlatıldığından, özel bellek ayırıcıları oluşturmak
    için ham bellek bloklarını ayırmak amacıyla <code>malloc(3)</code>
    çağrıları yapması gerekir.</p>

    <example>
/65:    fcntl(9, F_GETFL, 0x00000000)                   = 2<br />
/65:    fstat64(9, 0xFAF7B818)                          = 0<br />
/65:    getsockopt(9, 65535, 8192, 0xFAF7B918, 0xFAF7B910, 2190656) = 0<br />
/65:    fstat64(9, 0xFAF7B818)                          = 0<br />
/65:    getsockopt(9, 65535, 8192, 0xFAF7B918, 0xFAF7B914, 2190656) = 0<br />
/65:    setsockopt(9, 65535, 8192, 0xFAF7B918, 4, 2190656) = 0<br />
/65:    fcntl(9, F_SETFL, 0x00000082)                   = 0
    </example>

    <p>Ardından, worker evresi istemciye (dosya tanıtıcısı 9) engellenmeyen
    kipte bir bağlantı açar. <code>setsockopt(2)</code>
    ve <code>getsockopt(2)</code> çağrıları, Solaris libc'sinin soketler
    üzerindeki <code>fcntl(2)</code> çağrısı yanında birer yan etkiden
    ibarettirler.</p>

    <example>
      /65:    read(9, " G E T   / 1 0 k . h t m".., 8000)     = 97
    </example>

    <p>Worker evresi istemciden isteği okur.</p>

    <example>
/65:    stat("/var/httpd/apache/httpd-8999/htdocs/10k.html", 0xFAF7B978) = 0<br />
/65:    open("/var/httpd/apache/httpd-8999/htdocs/10k.html", O_RDONLY) = 10
    </example>

    <p>Bu httpd  <code>Options FollowSymLinks</code> ve <code>AllowOverride
    None</code> ile yapılandırılmıştır. Bu bakımdan, ne istenen dosya ile
    sonuçlanan yol üzerindeki her dizinde <code>lstat(2)</code> çağrısına ne
    de <code>.htaccess</code> dosyalarına bakılmasına gerek vardır.
    <code>stat(2)</code> çağrısı basitçe dosya için şunları doğrulamak
    amacıyla yapılır: 1) dosya mevcuttur ve 2) bir dizin değil normal bir
    dosyadır.</p>

    <example>
      /65:    sendfilev(0, 9, 0x00200F90, 2, 0xFAF7B53C)      = 10269
    </example>

    <p>Bu örnekte, httpd, istenen dosyayı ve HTTP yanıt başlığını tek bir
    <code>sendfilev(2)</code> sistem çağrısı ile  göndermektedir. Dosya
    gönderim işleminin anlamı sistemden sisteme değişiklik gösterir. Bazı
    sistemlerde, <code>sendfile(2)</code> çağrısından önce başlıkları
    göndermek için  <code>write(2)</code> veya <code>writev(2)</code>
    çağrısı yapmak gerekir.</p>

    <example>
      /65:    write(4, " 1 2 7 . 0 . 0 . 1   -  ".., 78)      = 78
    </example>

    <p>Bu <code>write(2)</code> çağrısı isteği erişim günlüğüne kaydeder. Bu
    izlemede eksik olan tek şey, <code>time(2)</code> çağrısıdır. Apache
    1.3'ün aksine, Apache 2.x zamana bakmak için
    <code>gettimeofday(3)</code> çağırısını kullanır. Linux ve Solaris gibi
    bazı işletim sistemleri, <code>gettimeofday</code> işlevinin, sıradan
    bir sistem çağrısından daha fazla götürüsü olmayan en iyilenmiş bir
    gerçeklenimine sahiptir.</p>

    <example>
      /65:    shutdown(9, 1, 1)                               = 0<br />
      /65:    poll(0xFAF7B980, 1, 2000)                       = 1<br />
      /65:    read(9, 0xFAF7BC20, 512)                        = 0<br />
      /65:    close(9)                                        = 0
    </example>

    <p>Burada worker evresi bağlantıyı zamana yaymaktadır.</p>

    <example>
      /65:    close(10)                                       = 0<br />
      /65:    lwp_park(0x00000000, 0)         (uykuda...)
    </example>

    <p>Son olarak, worker evresi teslim edilen dosyayı kapattıktan sonra
    dinleyici evre tarafından başka bir bağlantı atanıncaya kadar beklemeye
    alınır.</p>

    <example>
      /67:    accept(3, 0x001FEB74, 0x001FEB94, 1) (uykuda...)
    </example>

    <p>Bu arada, dinleyici evre bağlantıyı bir worker evresine atar atamaz
    başka bir bağlantıyı beklemeye başlar (Mevcut tüm evreler meşgulse
    dinleyici evreyi baskılayan worker MPM'nin akış denetim şemasına konu
    olur). Bu izlemede görünmüyor olsa da sonraki <code>accept(2)</code>
    çağrısı, yeni bağlantı kabul eden worker evresine paralel olarak
    yapılabilir (aşırı yük durumlarında normal olarak, bu yapılır).</p>

  </section>

</manualpage>

