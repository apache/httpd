<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
<!--
        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
              This file is generated from xml source: DO NOT EDIT
        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
      -->
<title>mod_lua - Serveur Apache HTTP Version 2.5</title>
<link href="../style/css/manual.css" rel="stylesheet" media="all" type="text/css" title="Main stylesheet" />
<link href="../style/css/manual-loose-100pc.css" rel="alternate stylesheet" media="all" type="text/css" title="No Sidebar - Default font size" />
<link href="../style/css/manual-print.css" rel="stylesheet" media="print" type="text/css" /><link rel="stylesheet" type="text/css" href="../style/css/prettify.css" />
<script src="../style/scripts/prettify.min.js" type="text/javascript">
</script>

<link href="../images/favicon.ico" rel="shortcut icon" /></head>
<body>
<div id="page-header">
<p class="menu"><a href="../mod/">Modules</a> | <a href="../mod/quickreference.html">Directives</a> | <a href="http://wiki.apache.org/httpd/FAQ">FAQ</a> | <a href="../glossary.html">Glossaire</a> | <a href="../sitemap.html">Plan du site</a></p>
<p class="apache">Serveur Apache HTTP Version 2.5</p>
<img alt="" src="../images/feather.png" /></div>
<div class="up"><a href="./"><img title="&lt;-" alt="&lt;-" src="../images/left.gif" /></a></div>
<div id="path">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">Serveur HTTP</a> &gt; <a href="http://httpd.apache.org/docs/">Documentation</a> &gt; <a href="../">Version 2.5</a> &gt; <a href="./">Modules</a></div>
<div id="page-content">
<div id="preamble"><h1>Module Apache mod_lua</h1>
<div class="toplang">
<p><span>Langues Disponibles: </span><a href="../en/mod/mod_lua.html" hreflang="en" rel="alternate" title="English">&nbsp;en&nbsp;</a> |
<a href="../fr/mod/mod_lua.html" title="Français">&nbsp;fr&nbsp;</a></p>
</div>
<table class="module"><tr><th><a href="module-dict.html#Description">Description:</a></th><td>Fournit des points d'entrée Lua dans différentes parties du
traitement des requêtes httpd</td></tr>
<tr><th><a href="module-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="module-dict.html#ModuleIdentifier">Identificateur de Module:</a></th><td>lua_module</td></tr>
<tr><th><a href="module-dict.html#SourceFile">Fichier Source:</a></th><td>mod_lua.c</td></tr>
<tr><th><a href="module-dict.html#Compatibility">Compatibilité:</a></th><td>versions 2.3 et supérieures</td></tr></table>
<h3>Sommaire</h3>

<p>Ce module permet d'ajouter au serveur des extensions sous forme de
scripts écrits dans le langage de programmation Lua.
<code class="module"><a href="../mod/mod_lua.html">mod_lua</a></code> fournit de nombreuses extensions
(hooks) disponibles avec les modules natifs du serveur HTTP Apache,
comme les associations de requêtes à des fichiers, la génération de
réponses dynamiques, le contrôle d'accès, l'authentification et
l'autorisation.</p>

<p>Vous trouverez davantage d'informations à propos du langage de
programmation Lua sur <a href="http://www.lua.org/">le site web de
Lua</a>.</p>

<div class="note"><code>mod_lua</code> est encore au stade expérimental. Son mode
d'utilisation et son comportement pourront changer à tout moment jusqu'à
ce qu'il passe au stade stable, et ce même entre deux versions stables
2.4.x. N'oublez pas de consulter le fichier CHANGES avant toute mise à
jour.</div>

<div class="warning"><h3>Avertissement</h3>
<p>Ce module possède une grande capacité d'action sur le fonctrionnement
de httpd, ce qui lui confère une grande puissance, mais peut aussi
induire un risque de sécurité. Il est déconseillé d'utiliser ce module
sur un serveur partagé avec des utilisateurs auxquels vous ne pouvez pas
accorder une confiance absolue, car il peut permettre de modifier le
fonctionnement interne de httpd.</p>
</div>

</div>
<div id="quickview"><h3>Sujets</h3>
<ul id="topics">
<li><img alt="" src="../images/down.gif" /> <a href="#basicconf">Configuration de base</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#writinghandlers">Ecrire des gestionnaires</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#writingauthzproviders">Ecriture de fournisseurs d'autorisation</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#writinghooks">Ecriture de fonctions d'accroche
(hooks)</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#datastructures">Structures de données</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#functions">Méthodes de l'objet request_rec</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#logging">Fonctions de journalisation</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#apache2">Paquet apache2</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#modifying_buckets">Modification de contenu avec les filtres lua</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#databases">Connectivité aux bases de données</a></li>
</ul><h3 class="directives">Directives</h3>
<ul id="toc">
<li><img alt="" src="../images/down.gif" /> <a href="#luaauthzprovider">LuaAuthzProvider</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luacodecache">LuaCodeCache</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahookaccesschecker">LuaHookAccessChecker</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahookauthchecker">LuaHookAuthChecker</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahookcheckuserid">LuaHookCheckUserID</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahookfixups">LuaHookFixups</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahookinsertfilter">LuaHookInsertFilter</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahooklog">LuaHookLog</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahookmaptostorage">LuaHookMapToStorage</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahooktranslatename">LuaHookTranslateName</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luahooktypechecker">LuaHookTypeChecker</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luainherit">LuaInherit</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luainputfilter">LuaInputFilter</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luamaphandler">LuaMapHandler</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luaoutputfilter">LuaOutputFilter</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luapackagecpath">LuaPackageCPath</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luapackagepath">LuaPackagePath</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luaquickhandler">LuaQuickHandler</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luaroot">LuaRoot</a></li>
<li><img alt="" src="../images/down.gif" /> <a href="#luascope">LuaScope</a></li>
</ul>
<h3>Traitement des bugs</h3><ul class="seealso"><li><a href="https://www.apache.org/dist/httpd/CHANGES_2.4">Journal des modifications de httpd</a></li><li><a href="https://bz.apache.org/bugzilla/buglist.cgi?bug_status=__open__&amp;list_id=144532&amp;product=Apache%20httpd-2&amp;query_format=specific&amp;order=changeddate%20DESC%2Cpriority%2Cbug_severity&amp;component=mod_lua">Problèmes connus</a></li><li><a href="https://bz.apache.org/bugzilla/enter_bug.cgi?product=Apache%20httpd-2&amp;component=mod_lua">Signaler un bug</a></li></ul><h3>Voir aussi</h3>
<ul class="seealso">
<li><a href="#comments_section">Commentaires</a></li></ul></div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="basicconf" id="basicconf">Configuration de base</a></h2>

<p>La directive de base pour le chargement du module est</p>

<pre class="prettyprint lang-config">LoadModule lua_module modules/mod_lua.so</pre>


<p>
<code>mod_lua</code> fournit un gestionnaire nommé
<code>lua-script</code> qui peut être utilisé avec une directive
<code class="directive"><a href="../mod/core.html#sethandler">SetHandler</a></code> ou <code class="directive"><a href="../mod/mod_mime.html#addhandler">AddHandler</a></code> :</p>

<pre class="prettyprint lang-config">&lt;Files "*.lua"&gt;
    SetHandler lua-script
&lt;/Files&gt;</pre>


<p>
Ceci aura pour effet de faire traiter les requêtes pour les fichiers
dont l'extension est <code>.lua</code> par <code>mod_lua</code> en
invoquant cette fonction de <code>gestion</code> de fichier.
</p>

<p>Pour plus de détails, voir la directive
<code class="directive">LuaMapHandler</code>.
 </p>
</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="writinghandlers" id="writinghandlers">Ecrire des gestionnaires</a></h2>
<p>Dans l'API du serveur HTTP Apache, un gestionnaire est une sorte de
point d'accroche (hook) spécifique responsable de la génération de la
réponse. <code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>, <code class="module"><a href="../mod/mod_cgi.html">mod_cgi</a></code> et
<code class="module"><a href="../mod/mod_status.html">mod_status</a></code> sont des exemples de modules comportant un
gestionnaire.</p>

<p><code>mod_lua</code> cherche toujours à invoquer une fonction Lua pour le
gestionnaire, plutôt que de simplement évaluer le corps d'un script dans
le style de CGI. Une fonction de gestionnaire se présente comme suit :</p>


<pre class="prettyprint lang-lua">
<strong>example.lua</strong><br />
-- exemple de gestionnaire

require "string"

--[[
     Il s'agit du nom de méthode par défaut pour les gestionnaires Lua ;
     voir les noms de fonctions optionnels dans la directive
     LuaMapHandler pour choisir un point d'entrée différent.
--]]
function handle(r)
    r.content_type = "text/plain"

    if r.method == 'GET' then
    	r:puts("Hello Lua World!\n")
        for k, v in pairs( r:parseargs() ) do
            r:puts( string.format("%s: %s\n", k, v) )
        end
    elseif r.method == 'POST' then
    	r:puts("Hello Lua World!\n")
        for k, v in pairs( r:parsebody() ) do
            r:puts( string.format("%s: %s\n", k, v) )
        end
    else
    elseif r.method == 'PUT' then
-- message d'erreur personnalisé
        r:puts("Unsupported HTTP method " .. r.method)
	r.status = 405
        return apache2.OK
    else
-- message d'erreur ErrorDocument
        return 501
    end
    return apache2.OK
end</pre>


<p>
Ce gestionnaire se contente d'afficher les arguments codés d'un uri ou
d'un formulaire dans un page au format texte.
</p>

<p>
Cela signifie que vous pouvez (et êtes encouragé à) avoir plusieurs
gestionnaires (ou points d'entrée, ou filtres) dans le même script.
</p>

</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="writingauthzproviders" id="writingauthzproviders">Ecriture de fournisseurs d'autorisation</a></h2>


<p><code class="module"><a href="../mod/mod_authz_core.html">mod_authz_core</a></code> fournit une interface d'autorisation
de haut niveau bien plus facile à utiliser que dans les hooks
correspondants. Le premier argument de la directive <code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code> permet de spécifier le
fournisseur d'autorisation à utiliser. Pour chaque directive <code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code>,
<code class="module"><a href="../mod/mod_authz_core.html">mod_authz_core</a></code> appellera le fournisseur d'autorisation
spécifié, le reste de la ligne constituant les paramètres. Le
fournisseur considéré va alors vérifier les autorisations et fournir le
résultat dans une valeur de retour.</p>

<p>En général, le fournisseur authz est appelé avant l'authentification.
S'il doit connaître le nom d'utilisateur authentifié (ou si
l'utilisateur est appelé à être authentifié), le fournisseur doit
renvoyer <code>apache2.AUTHZ_DENIED_NO_USER</code>, ce qui va
déclancher le processus d'authentification et un deuxième appel du
fournisseur authz.</p>

<p>La fonction du fournisseur authz ci-dessous accepte deux arguments,
une adresse IP et un nom d'utilisateur. Elle autorise l'accès dans le
cas où la requête provient de l'adresse IP spécifiée, ou si
l'utilisateur authentifié correspond au second argument :</p>

<pre class="prettyprint lang-lua">
<strong>authz_provider.lua</strong><br />

require 'apache2'

function authz_check_foo(r, ip, user)
    if r.useragent_ip == ip then
        return apache2.AUTHZ_GRANTED
    elseif r.user == nil then
        return apache2.AUTHZ_DENIED_NO_USER
    elseif r.user == user then
        return apache2.AUTHZ_GRANTED
    else
        return apache2.AUTHZ_DENIED
    end
end</pre>


<p>La configuration suivante enregistre cette fonction en tant que
fournisseur <code>foo</code>, et la configure por l'URL <code>/</code> :</p>
<pre class="prettyprint lang-config">LuaAuthzProvider foo authz_provider.lua authz_check_foo
&lt;Location "/"&gt;
  Require foo 10.1.2.3 john_doe
&lt;/Location&gt;</pre>


</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="writinghooks" id="writinghooks">Ecriture de fonctions d'accroche
(hooks)</a></h2>

<p>Les fonctions d'accroche déterminent la manière dont les modules (et
les scripts Lua) participent au traitement des requêtes. Chaque type
d'accroche proposé par le serveur a un rôle spécifique, comme
l'association de requêtes au système de fichiers, le contrôle d'accès,
ou la définition de types MIME : </p>

<table class="bordered"><tr class="header">
        <th>Phase d'accroche</th>
        <th>Directive mod_lua</th>
        <th>Description</th>
    </tr>
<tr>
        <td>Gestionnaire rapide</td>
        <td><code class="directive"><a href="#luaquickhandler">LuaQuickHandler</a></code></td>
        <td>Il s'agit de la première accroche appelée lorsqu'une requête
	a été associée à un serveur ou un serveur virtuel.</td>
    </tr>
<tr class="odd">
        <td>Phase de traduction</td>
        <td><code class="directive"><a href="#luahooktranslatename">LuaHookTranslateName</a></code></td>
        <td>Cette phase traduit l'URI de la requête en nom de fichier
	sur le système. Ce sont des modules comme
	<code class="module"><a href="../mod/mod_alias.html">mod_alias</a></code> et <code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code> qui
	interviennent au cours de cette phase.</td>
    </tr>
<tr>
        <td>Choix du lieu de stockage de la ressource</td>
        <td><code class="directive"><a href="#luahookmaptostorage">LuaHookMapToStorage</a></code></td>
        <td>Cette phase définit le lieu de stockage de la ressource :
	physique, en cache ou externe/mandaté. Elle est assurée par les
	modules de mandat ou de mise en cache.</td>
    </tr>
<tr class="odd">
        <td>Autorisation d'accès</td>
        <td><code class="directive"><a href="#luahookaccesschecker">LuaHookAccessChecker</a></code></td>
        <td>Cette phase vérifie si un client a l'autorisation d'accès à
	la ressource. Elle s'exécute avant l'authentification de
	l'utisateur ; il faut donc être prudent.
        </td>
    </tr>
<tr>
        <td>Vérification de l'identifiant utilisateur</td>
        <td><code class="directive"><a href="#luahookcheckuserid">LuaHookCheckUserID</a></code></td>
        <td>Cette phase vérifie l'identifiant de l'utilisateur ayant
	fait l'objet d'une négociation.</td>
    </tr>
<tr class="odd">
        <td>Vérification de l'autorisation d'accès</td>
        <td><code class="directive"><a href="#luahookauthchecker">LuaHookAuthChecker</a></code>
	ou
            <code class="directive"><a href="#luaauthzprovider">LuaAuthzProvider</a></code></td>
        <td>Cette phase vérifie l'autorisation d'accès d'un utilisateur
	en fonction des ses paramètres de connexion, comme
	l'identifiant, le certificat, etc...
        </td>
    </tr>
<tr>
        <td>Vérification du type de la ressource</td>
        <td><code class="directive"><a href="#luahooktypechecker">LuaHookTypeChecker</a></code></td>
        <td>Cette phase assigne un type de contenu et un gestionnaire à
	la ressource.</td>
    </tr>
<tr class="odd">
        <td>Derniers réglages</td>
        <td><code class="directive"><a href="#luahookfixups">LuaHookFixups</a></code></td>
        <td>C'est la dernière phase avant l'activation des gestionnaires
	de contenu. Toute modification de dernière minute à la requête
	doit être effectuée ici.</td>
    </tr>
<tr>
        <td>Gestionnaire de contenu</td>
        <td>fichiers fx. <code>.lua</code> ou directive <code class="directive"><a href="#luamaphandler">LuaMapHandler</a></code></td>
        <td>C'est durant cette phase que le contenu est traité. Les
	fichiers sont lus, interprétés, certains sont exécutés, et le
	résultat obtenu est envoyé au client.</td>
    </tr>
<tr class="odd">
        <td>Journalisation</td>
        <td><code class="directive"><a href="#luahooklog">LuaHookLog</a></code></td>
        <td>Lorsqu'une requête a été traitée, plusieurs phases de
	journalisation interviennent, et enregistrent leurs résultats
	dans les fichiers d'erreur ou d'accès. Mod_lua peut
	s'intercaler au départ de ce processus et ainsi contrôler la
	journalisation.</td>
    </tr>
</table>

<p>Les fonctions d'accroche reçoivent l'objet de la requête comme seul
argument (sauf LuaAuthzProvider qui reçoit aussi des arguments en
provenance de la directive Require). Elles peuvent renvoyer une valeur,
selon la fonction, mais il s'agit en général d'un
code d'état HTTP ou des valeurs OK, DONE, ou DECLINED,
que vous pouvez écrire dans Lua sous la forme <code>apache2.OK</code>,
<code>apache2.DONE</code>, ou <code>apache2.DECLINED</code>.</p>


<pre class="prettyprint lang-lua">
<strong>translate_name.lua</strong><br />
-- exemple d'accroche qui réécrit un URI en chemin du système de fichiers.

require 'apache2'

function translate_name(r)
    if r.uri == "/translate-name" then
        r.filename = r.document_root .. "/find_me.txt"
        return apache2.OK
    end
    -- on ne gère pas cette URL et on donne sa chance à un autre module
    return apache2.DECLINED
end</pre>



<pre class="prettyprint lang-lua">
<strong>translate_name2.lua</strong><br />
--[[ exemple d'accroche qui réécrit un URI vers un autre URI. Il renvoie
	un apache2.DECLINED pour permettre à un autre interpréteur d'URL de
	travailler sur la substitution, y compris l'accroche translate_name
	de base dont les tables de correspondances se basent sur DocumentRoot.

     Note: utilisez le drapeau early/late de la directive pour
     l'exécuter avant ou après mod_alias.
--]]

require 'apache2'

function translate_name(r)
    if r.uri == "/translate-name" then
        r.uri = "/find_me.txt"
        return apache2.DECLINED
    end
    return apache2.DECLINED
end</pre>

</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="datastructures" id="datastructures">Structures de données</a></h2>

<dl>
<dt>request_rec</dt>
        <dd>
        <p>request_rec est considérée en tant que donnée utilisateur.
	Elle possède une métatable qui vous permet d'accomplir des
	choses intéressantes. Pour la plus grande partie, elle possède
	les mêmes champs que la structure request_rec, la
	plupart d'entre eux étant accessibles en lecture et écriture (le
	contenu des champs de la table peut être modifié, mais les
	champs eux-mêmes ne peuvent pas être établis en tant que tables
	distinctes).</p>

	<table class="bordered"><tr class="header">
          <th><strong>Nom</strong></th>
          <th><strong>Type Lua</strong></th>
          <th><strong>Modifiable</strong></th>
	  <th><strong>Description</strong></th>
        </tr>
<tr>
          <td><code>allowoverrides</code></td>
          <td>string</td>
          <td>non</td>
          <td>L'option AllowOverride s'applique à la requête courante.</td>
        </tr>
<tr class="odd">
          <td><code>ap_auth_type</code></td>
          <td>string</td>
          <td>non</td>
	  <td>Ce champ contient le type d'authentification effectuée
	  (par exemple <code>basic</code>)</td>
        </tr>
<tr>
          <td><code>args</code></td>
          <td>string</td>
          <td>oui</td>
	  <td>La chaîne de paramètres de la requête (par exemple
	  <code>foo=bar&amp;name=johnsmith</code>)</td>
        </tr>
<tr class="odd">
          <td><code>assbackwards</code></td>
          <td>boolean</td>
          <td>non</td>
	  <td>contient true s'il s'agit d'une requête de style HTTP/0.9
	  (par exemple <code>GET /foo</code> (sans champs d'en-tête) )</td>
        </tr>
<tr>
          <td><code>auth_name</code></td>
          <td>string</td>
          <td>non</td>
          <td>La chaîne d'identification utilisée pour la vérification
	  de l'autorisation d'accès (si elle est disponible).</td>
        </tr>
<tr class="odd">
          <td><code>banner</code></td>
          <td>string</td>
          <td>non</td>
          <td>La bannière du serveur, par exemple <code>Apache HTTP
	  Server/2.4.3 openssl/0.9.8c</code></td>
        </tr>
<tr>
          <td><code>basic_auth_pw</code></td>
          <td>string</td>
          <td>non</td>
          <td>Le mot de passe pour l'authentification de base envoyé
	  avec la requête, s'il existe</td>
        </tr>
<tr class="odd">
          <td><code>canonical_filename</code></td>
          <td>string</td>
          <td>non</td>
	  <td>Le nom de fichier canonique de la requête</td>
        </tr>
<tr>
          <td><code>content_encoding</code></td>
          <td>string</td>
          <td>non</td>
	  <td>Le type de codage du contenu de la requête courante</td>
        </tr>
<tr class="odd">
          <td><code>content_type</code></td>
          <td>string</td>
          <td>oui</td>
	  <td>Le type de contenu de la requête courante, tel qu'il a été
	  déterminé au cours de la phase type_check (par exemple
	  <code>image/gif</code> ou <code>text/html</code>)</td>
        </tr>
<tr>
          <td><code>context_prefix</code></td>
          <td>string</td>
          <td>non</td>
	  <td />
        </tr>
<tr class="odd">
          <td><code>context_document_root</code></td>
          <td>string</td>
          <td>non</td>
	  <td />
        </tr>
<tr>
          <td><code>document_root</code></td>
          <td>string</td>
          <td>non</td>
	  <td>La racine des documents du serveur</td>
        </tr>
<tr class="odd">
          <td><code>err_headers_out</code></td>
          <td>table</td>
          <td>non</td>
	  <td>L'en-tête MIME de l'environnement pour la réponse, écrit
	  même en cas d'erreur et conservé pendant les redirections
	  internes</td>
        </tr>
<tr>
          <td><code>filename</code></td>
          <td>string</td>
          <td>oui</td>
	  <td>Le nom de fichier correspondant à la requête, par exemple
	  /www/example.com/foo.txt. Il peut être modifié au cours des
	  phases translate-name ou map-to-storage du traitement de la
	  requête pour permettre au gestionnaire par défaut (ou aux
	  gestionnaires de script) de servir une version du fichier
	  autre que celle demandée.</td>
        </tr>
<tr class="odd">
          <td><code>handler</code></td>
          <td>string</td>
          <td>oui</td>
	  <td>Le nom du <a href="../handler.html">gestionnaire</a> qui
	  doit traiter la requête, par exemple <code>lua-script</code>
	  si elle doit être traitée par mod_lua. Cette valeur est en
	  général définie via les directives <code class="directive"><a href="../mod/mod_mime.html#addhandler">AddHandler</a></code> ou <code class="directive"><a href="../mod/core.html#sethandler">SetHandler</a></code>, mais peut aussi l'être
	  via mod_lua pour permettre à un autre gestionnaire de traiter
	  une requête spécifique qui ne serait pas traitée par défaut
	  par ce dernier.
            </td>
        </tr>
<tr>
	  <td><code>headers_in</code></td>
          <td>table</td>
          <td>oui</td>
	  <td>Les en-têtes MIME de l'environnement de la requête. Il
	  s'agit des en-têtes comme <code>Host, User-Agent,
	  Referer</code>, etc...</td>
        </tr>
<tr class="odd">
          <td><code>headers_out</code></td>
          <td>table</td>
          <td>oui</td>
	  <td>Les en-têtes MIME de l'environnement de la réponse.</td>
        </tr>
<tr>
          <td><code>hostname</code></td>
          <td>string</td>
          <td>non</td>
	  <td>Le nom d'hôte, tel que défini par l'en-tête
	  <code>Host:</code> ou par un URI complet.</td>
        </tr>
<tr class="odd">
          <td><code>is_https</code></td>
          <td>boolean</td>
          <td>non</td>
          <td>Indique si la requête à été faite via HTTPS</td>
        </tr>
<tr>
          <td><code>is_initial_req</code></td>
          <td>boolean</td>
          <td>non</td>
          <td>Indique si la requête courante est la requête initiale ou
	  une sous-requête.</td>
        </tr>
<tr class="odd">
          <td><code>limit_req_body</code></td>
          <td>number</td>
          <td>non</td>
          <td>La taille maximale du corps de la requête, ou 0 si aucune
	  limite.</td>
        </tr>
<tr>
	<td><code>log_id</code></td>
          <td>string</td>
          <td>non</td>
	  <td>L'identifiant de la requête dans les journaux d'accès ou
	  d'erreur.</td>
        </tr>
<tr class="odd">
          <td><code>method</code></td>
          <td>string</td>
          <td>non</td>
	  <td>La méthode de la requête, par exemple <code>GET</code> ou
	  <code>POST</code>.</td>
        </tr>
<tr>
          <td><code>notes</code></td>
          <td>table</td>
          <td>oui</td>
	  <td>Une liste de notes qui peuvent être transmises d'un module
	  à l'autre.</td>
        </tr>
<tr class="odd">
          <td><code>options</code></td>
          <td>string</td>
          <td>non</td>
          <td>La valeur de la directive Options pour la requête
	  courante.</td>
        </tr>
<tr>
          <td><code>path_info</code></td>
          <td>string</td>
          <td>non</td>
	  <td>La valeur de PATH_INFO extraite de la requête.</td>
        </tr>
<tr class="odd">
          <td><code>port</code></td>
          <td>number</td>
          <td>non</td>
          <td>Le port du serveur utilisé par la requête.</td>
        </tr>
<tr>
          <td><code>protocol</code></td>
          <td>string</td>
          <td>non</td>
	  <td>Le protocole utilisé, par exemple <code>HTTP/1.1</code></td>
        </tr>
<tr class="odd">
          <td><code>proxyreq</code></td>
          <td>string</td>
          <td>oui</td>
	  <td>Indique s'il s'agit d'une requête mandatée ou non. Cette
	  valeur est en général définie au cours de la phase
	  post_read_request/translate_name du traitement de la requête.</td>
        </tr>
<tr>
	  <td><code>range</code></td>
          <td>string</td>
          <td>non</td>
	  <td>Le contenu de l'en-tête <code>Range:</code>.</td>
        </tr>
<tr class="odd">
          <td><code>remaining</code></td>
          <td>number</td>
          <td>non</td>
          <td>Le nombre d'octets du corps de la requête restant à lire.</td>
        </tr>
<tr>
          <td><code>server_built</code></td>
          <td>string</td>
          <td>non</td>
          <td>La date de compilation du serveur.</td>
        </tr>
<tr class="odd">
          <td><code>server_name</code></td>
          <td>string</td>
          <td>non</td>
          <td>Le nom du serveur pour cette requête.</td>
        </tr>
<tr>
          <td><code>some_auth_required</code></td>
          <td>boolean</td>
          <td>non</td>
          <td>Indique si une autorisation est/était requise pour cette
	  requête.</td>
        </tr>
<tr class="odd">
          <td><code>subprocess_env</code></td>
          <td>table</td>
          <td>oui</td>
	  <td>Le jeu de variables d'environnement pour cette requête.</td>
        </tr>
<tr>
          <td><code>started</code></td>
          <td>number</td>
          <td>non</td>
          <td>Le moment où le serveur a été (re)démarré, en secondes
	  depuis epoch (1er janvier 1970)</td>
        </tr>
<tr class="odd">
	  <td><code>status</code></td>
          <td>number</td>
          <td>oui</td>
	  <td>Le code de retour (courant) pour cette requête, par
	  exemple <code>200</code> ou <code>404</code>.</td>
        </tr>
<tr>
          <td><code>the_request</code></td>
          <td>string</td>
          <td>non</td>
	  <td>La chaîne de la requête telle qu'elle a été envoyée par le
	  client, par exemple <code>GET /foo/bar HTTP/1.1</code>.</td>
        </tr>
<tr class="odd">
          <td><code>unparsed_uri</code></td>
          <td>string</td>
          <td>non</td>
	  <td>La partie URI non interprétée de la requête</td>
        </tr>
<tr>
          <td><code>uri</code></td>
          <td>string</td>
          <td>oui</td>
	  <td>L'URI après interprétation par httpd</td>
        </tr>
<tr class="odd">
          <td><code>user</code></td>
          <td>string</td>
          <td>oui</td>
	  <td>Si une authentification a été effectuée, nom de
	  l'utilisateur authentifié.</td>
        </tr>
<tr>
          <td><code>useragent_ip</code></td>
          <td>string</td>
          <td>non</td>
	  <td>L'adresse IP de l'agent qui a envoyé la requête</td>
        </tr>
</table>
	</dd>
    </dl>
</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="functions" id="functions">Méthodes de l'objet request_rec</a></h2>

<p>L'objet request_rec possède (au minimum) les méthodes suivantes :</p>

<pre class="prettyprint lang-lua">r:flush()   -- vide le tampon de sortie
            -- Renvoie true si le vidage a été effectué avec succès,
	    -- false dans le cas contraire.

while nous_avons_des_données_à_envoyer do
    r:puts("Bla bla bla\n") -- envoi des données à envoyer vers le tampon
    r:flush() -- vidage du tampon (envoi au client)
    r.usleep(500000) -- mise en attente pendant 0.5 secondes et bouclage
end</pre>


<pre class="prettyprint lang-lua">r:addoutputfilter(name|function) -- ajoute un filtre en sortie

r:addoutputfilter("fooFilter") -- insère le filtre fooFilter dans le flux de sortie</pre>


<pre class="prettyprint lang-lua">r:sendfile(filename) -- envoie un fichier entier au client en utilisant sendfile s'il est
                     -- supporté par la plateforme :

if use_sendfile_thing then
    r:sendfile("/var/www/large_file.img")
end</pre>


<pre class="prettyprint lang-lua">r:parseargs() -- renvoie deux tables : une table standard de couples
              -- clé/valeur pour les données GET simples,
              -- et une autre pour les données
              -- multivaluées (par exemple foo=1&amp;foo=2&amp;foo=3) :

local GET, GETMULTI = r:parseargs()
r:puts("Votre nom est : " .. GET['name'] or "Unknown")</pre>



<pre class="prettyprint lang-lua">r:parsebody()([sizeLimit]) -- interprète le corps de la
                           -- requête en tant que POST et renvoie
                           -- deux tables lua, comme r:parseargs(). Un
                           -- nombre optionnel peut être fourni
                           -- pour spécifier le nombre maximal
                           -- d'octets à interpréter. La
                           -- valeur par défaut est 8192.

local POST, POSTMULTI = r:parsebody(1024*1024)
r:puts("Votre nom est : " .. POST['name'] or "Unknown")</pre>



<pre class="prettyprint lang-lua">r:puts("bonjour", " le monde", "!") -- affichage dans le corps de la réponse</pre>


<pre class="prettyprint lang-lua">r:write("une simple chaîne") -- affichage dans le corps de la réponse</pre>


<pre class="prettyprint lang-lua">r:escape_html("&lt;html&gt;test&lt;/html&gt;") -- Echappe le code HTML et renvoie le résultat</pre>


<pre class="prettyprint lang-lua">r:base64_encode(string) -- Encode une chaîne à l'aide du standard de codage Base64.

local encoded = r:base64_encode("This is a test") -- returns VGhpcyBpcyBhIHRlc3Q=</pre>


<pre class="prettyprint lang-lua">r:base64_decode(string) -- Décode une chaîne codée en Base64.

local decoded = r:base64_decode("VGhpcyBpcyBhIHRlc3Q=") -- returns 'This is a test'</pre>


<pre class="prettyprint lang-lua">r:md5(string) -- Calcule et renvoie le condensé MD5 d'une chaîne en mode binaire (binary safe).

local hash = r:md5("This is a test") -- returns ce114e4501d2f4e2dcea3e17b546f339</pre>


<pre class="prettyprint lang-lua">r:sha1(string) -- Calcule et renvoie le condensé SHA1 d'une chaîne en mode binaire (binary safe).

local hash = r:sha1("This is a test") -- returns a54d88e06612d820bc3be72877c74f257b561b19</pre>


<pre class="prettyprint lang-lua">r:escape(string) -- Echappe une chaîne de type URL.

local url = "http://foo.bar/1 2 3 &amp; 4 + 5"
local escaped = r:escape(url) -- renvoie 'http%3a%2f%2ffoo.bar%2f1+2+3+%26+4+%2b+5'</pre>


<pre class="prettyprint lang-lua">r:unescape(string) -- Déséchappe une chaîne de type URL.

local url = "http%3a%2f%2ffoo.bar%2f1+2+3+%26+4+%2b+5"
local unescaped = r:unescape(url) -- renvoie 'http://foo.bar/1 2 3 &amp; 4 + 5'</pre>


<pre class="prettyprint lang-lua">r:construct_url(string) -- Construit une URL à partir d'un URI

local url = r:construct_url(r.uri)</pre>


<pre class="prettyprint lang-lua">r.mpm_query(number) -- Interroge le serveur à propos de son module MPM via la requête ap_mpm_query.

local mpm = r.mpm_query(14)
if mpm == 1 then
    r:puts("Ce serveur utilise le MPM Event")
end</pre>


<pre class="prettyprint lang-lua">r:expr(string) -- Evalue une chaîne de type <a href="../expr.html">expr</a>.

if r:expr("%{HTTP_HOST} =~ /^www/") then
    r:puts("Ce nom d'hôte commence par www")
end</pre>


<pre class="prettyprint lang-lua">r:scoreboard_process(a) -- Interroge le serveur à propos du
                        -- processus à la position <code>a</code>.

local process = r:scoreboard_process(1)
r:puts("Le serveur 1 a comme PID " .. process.pid)</pre>


<pre class="prettyprint lang-lua">r:scoreboard_worker(a, b) -- Interroge le serveur à propos du
                          -- thread <code>b</code>, dans le processus <code>a</code>.

local thread = r:scoreboard_worker(1, 1)
r:puts("L'ID du thread 1 du serveur 1 est " .. thread.tid .. " et son
état est " .. thread.status)</pre>


<pre class="prettyprint lang-lua">r:clock() -- Renvoie l'heure courante avec une précision d'une microseconde.</pre>


<pre class="prettyprint lang-lua">r:requestbody(filename) -- Lit et renvoie le corps d'une requête.
                        -- Si 'filename' est spécifié, le
                        -- corps de requête n'est pas
                        -- renvoyé, mais sauvegardé dans
                        -- le fichier correspondant.

local input = r:requestbody()
r:puts("Vous m'avez envoyé le corps de requête suivant :\n")
r:puts(input)</pre>


<pre class="prettyprint lang-lua">r:add_input_filter(filter_name) -- Ajoute le filtre en entrée 'filter_name'.</pre>


<pre class="prettyprint lang-lua">r:module_info(module_name) -- Interroge le serveur à propos d'un module.

local mod = r.module_info("mod_lua.c")
if mod then
    for k, v in pairs(mod.commands) do
       r:puts( ("%s: %s\n"):format(k,v)) -- affiche toutes les directives
                                         -- implémentées par ce module.
    end
end</pre>


<pre class="prettyprint lang-lua">r:loaded_modules() -- Renvoie une liste des modules chargés par httpd.

for k, module in pairs(r:loaded_modules()) do
    r:puts("J'ai chargé le module " .. module .. "\n")
end</pre>


<pre class="prettyprint lang-lua">r:runtime_dir_relative(filename) -- Génère le nom d'un fichier run-time
                                 -- (par exemple la mémoire partagée
                                 -- "file") relativement au répertoire de run-time.</pre>


<pre class="prettyprint lang-lua">r:server_info() -- Renvoie une table contenant des informations à
                -- propos du serveur, comme le nom de
                -- l'exécutable httpd, le module mpm utilisé, etc...</pre>


<pre class="prettyprint lang-lua">r:set_document_root(file_path) -- Définit la racine des documents
                               -- pour la requête à file_path.</pre>


<pre class="prettyprint lang-lua">r:add_version_component(component_string) -- Ajoute un élément à
                                          -- la bannière du serveur.</pre>


<pre class="prettyprint lang-lua">r:set_context_info(prefix, docroot) -- Définit le préfixe et la
                                    -- racine des documents du contexte pour une requête.</pre>


<pre class="prettyprint lang-lua">r:os_escape_path(file_path) -- Convertit un chemin du système de
                            -- fichiers en URL indépendamment du système d'exploitation.</pre>


<pre class="prettyprint lang-lua">r:escape_logitem(string) -- Echappe une chaîne pour journalisation.</pre>


<pre class="prettyprint lang-lua">r.strcmp_match(string, pattern) -- Vérifie si 'string' correspond à
                                -- 'pattern' via la fonction strcmp_match (GLOBs). Par exemple, est-ce que
                                -- 'www.example.com' correspond à '*.example.com' ?

local match = r.strcmp_match("foobar.com", "foo*.com")
if match then 
    r:puts("foobar.com matches foo*.com")
end</pre>


<pre class="prettyprint lang-lua">r:set_keepalive() -- Définit l'état de persistance d'une requête.
                  -- Renvoie true dans la mesure du possible, false dans le cas contraire.</pre>


<pre class="prettyprint lang-lua">r:make_etag() -- Génère et renvoie le etag pour la requête courante.</pre>


<pre class="prettyprint lang-lua">r:send_interim_response(clear) -- Renvoie une réponse d'intérim (1xx) au
                               -- client. Si 'clear' est vrai, les en-têtes disponibles
                               -- seront envoyés et effacés.</pre>


<pre class="prettyprint lang-lua">r:custom_response(status_code, string) -- Génère et définit une réponse
                                       -- personnalisée pour un code d'état particulier.
                                       -- Le fonctionnement est très proche de celui de la directive ErrorDocument.

r:custom_response(404, "Baleted!")</pre>


<pre class="prettyprint lang-lua">r.exists_config_define(string) -- Vérifie si une définition de configuration existe.

if r.exists_config_define("FOO") then
    r:puts("httpd a probablement été lancé avec l'option -DFOO, ou FOO a
    été défini dans la configuration")
end</pre>


<pre class="prettyprint lang-lua">r:state_query(string) -- Interroge le serveur à propos de son état.</pre>


<pre class="prettyprint lang-lua">r:stat(filename [,wanted]) -- Exécute stat() sur un fichier, et renvoie une table contenant
                           -- des informations à propos de ce fichier.

local info = r:stat("/var/www/foo.txt")
if info then
    r:puts("Ce fichier existe et a été modifié pour la dernière fois à : " .. info.modified)
end</pre>


<pre class="prettyprint lang-lua">r:regex(string, pattern [,flags]) -- Exécute une recherche à base d'expression rationnelle
                                  -- sur une chaîne, et renvoie les éventuelles correspondances trouvées.

local matches = r:regex("foo bar baz", [[foo (\w+) (\S*)]])
if matches then
    r:puts("L'expression rationnelle correspond et le dernier mot
    capturé ($2) est : " .. matches[2])
end

-- Exemple avec insensibilité à la casse :
local matches = r:regex("FOO bar BAz", [[(foo) bar]], 1)

-- les drapeaux peuvent être une combibaison bit à bit de :
-- 0x01: insensibilité à la casse
-- 0x02: recherche multiligne</pre>


<pre class="prettyprint lang-lua">r.usleep(microsecondes) -- Interrompt l'exécution du script pendant le nombre de microsecondes spécifié.</pre>


<pre class="prettyprint lang-lua">r:dbacquire(dbType[, dbParams]) -- Acquiert une connexion à une base de données et renvoie une classe database.
                                -- Voir '<a href="#databases">Connectivité aux bases de données</a>'
				-- pour plus de détails.</pre>


<pre class="prettyprint lang-lua">r:ivm_set("key", value) -- Défini une variable Inter-VM avec une valeur spécifique.
                        -- Ces valeurs sont conservées même si la VM est
			-- arrêtée ou non utilisée, et ne doivent donc être
			-- utilisées que si MaxConnectionsPerChild &gt; 0.
			-- Les valeurs peuvent être de type number, string
			-- ou boolean et sont stockées séparément pour
			-- chaque processus (elles ne seront donc pas d'une
			-- grande utilité si l'on utilise le mpm prefork).
                        
r:ivm_get("key")        -- Lit le contenu d'une variable définie via ivm_set. Renvoie
			-- le contenu de la variable si elle existe, ou nil
			-- dans le cas contraire.
                        
-- Voici un exemple de lecture/écriture qui sauvegarde une variable
-- globale en dehors de la VM :
function handle(r)
    -- La première VM qui effectue l'appel suivant n'obtiendra aucune
    -- valeur, et devra la créer
    local foo = r:ivm_get("cached_data")
    if not foo then
        foo = do_some_calcs() -- simulation de valeurs de retour
        r:ivm_set("cached_data", foo) -- définition globale de la variable
    end
    r:puts("La donnée en cache est : ", foo)
end</pre>

<pre class="prettyprint lang-lua">r:htpassword(string [,algorithm [,cost]]) -- Génère un hash de mot de passe à partir d'une chaîne.
                                          -- algorithm: 0 = APMD5 (défaut), 1 = SHA, 2 = BCRYPT, 3 = CRYPT.
                                          -- cost: ne s'utilise qu'avec l'algorythme BCRYPT (défaut = 5).</pre>


<pre class="prettyprint lang-lua">r:mkdir(dir [,mode]) -- Crée un répertoire et définit son mode via le paramètre optionnel mode.</pre>


<pre class="prettyprint lang-lua">r:mkrdir(dir [,mode]) -- Crée des répertoires de manière récursive et définit
                      -- leur mode via le paramètre optionnel mode.</pre>


<pre class="prettyprint lang-lua">r:rmdir(dir) -- Supprime un répertoire.</pre>


<pre class="prettyprint lang-lua">r:touch(file [,mtime]) -- Définit la date de modification d'un fichier à la date courante ou à
                       -- la valeur optionnelle mtime en msec.</pre>


<pre class="prettyprint lang-lua">r:get_direntries(dir) -- Renvoie une table contenant toutes les entrées de répertoires.

-- Renvoie un chemin sous forme éclatée en chemin, fichier, extension
function handle(r)
  local dir = r.context_document_root
  for _, f in ipairs(r:get_direntries(dir)) do
    local info = r:stat(dir .. "/" .. f)
    if info then
      local mtime = os.date(fmt, info.mtime / 1000000)
      local ftype = (info.filetype == 2) and "[dir] " or "[file]"
      r:puts( ("%s %s %10i %s\n"):format(ftype, mtime, info.size, f) )
    end
  end
end</pre>


<pre class="prettyprint lang-lua">r.date_parse_rfc(string) -- Interprète une chaîne date/heure et renvoie l'équivalent en secondes depuis epoche.</pre>


<pre class="prettyprint lang-lua">r:getcookie(key) -- Obtient un cookie HTTP</pre>


<pre class="prettyprint lang-lua">r:setcookie(key, value, secure, expires) -- Définit un cookie HTTP, par exemple :
r:setcookie("foo", "bar and stuff", false, os.time() + 86400)</pre>


<pre class="prettyprint lang-lua">r:wsupgrade() -- Met à jour une connexion vers les WebSockets si possible (et si demandé) :
if r:wsupgrade() then -- si la mise à jour est possible :
    r:wswrite("Bienvenue dans les websockets!") -- écrit quelque chose à l'intention du client
    r:wsclose()  -- Au revoir !
end</pre>


<pre class="prettyprint lang-lua">r:wsread() -- Lit un cadre de websocket depuis une connexion vers websocket mise à jour (voir ci-dessus) :
           
local line, isFinal = r:wsread() -- isFinal indique s'il s'agit du cadre final.
                                 -- dans le cas contraire, on peut lire les cadres suivants
r:wswrite("Vous avez écrit : " .. line)</pre>


<pre class="prettyprint lang-lua">r:wswrite(line) -- écrit un cadre vers un client WebSocket :
r:wswrite("Bonjour le Monde !")</pre>


<pre class="prettyprint lang-lua">r:wsclose() -- ferme une requête WebSocket et l'achève pour httpd :

if r:wsupgrade() then
    r:wswrite("Ecrire quelque chose : ")
    local line = r:wsread() or "nothing"
    r:wswrite("Vous avez écrit : " .. line);
    r:wswrite("Au revoir !")
    r:wsclose()
end</pre>

<pre class="prettyprint lang-lua">r:wspeek() -- Vérifie s'il y a des données à lire

-- Se met en sommeil tant que rien ne nous est envoyé ...
while r:wspeek() == false do
   r.usleep(50000)
end
-- Il y a des données à lire !
local line = r:wsread()</pre>



<pre class="prettyprint lang-lua">r:config() -- Extrait une arborescence de l'ensemble de
	   -- la configuration de httpd pouvant être parcourue</pre>


<pre class="prettyprint lang-lua">r:activeconfig() -- Extrait une arborescence de la configuration active
		 -- de httpd (pour le serveur virtuel sélectionné)</pre>



</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="logging" id="logging">Fonctions de journalisation</a></h2>

<pre class="prettyprint lang-lua">	-- exemples de messages de journalisation
	r:trace1("Ceci est un message de journalisation de niveau
	trace") -- les niveaux valides vont de trace1 à trace8 
        r:debug("Ceci est un message de journalisation de niveau debug")
        r:info("Ceci est un message de journalisation de niveau info")
        r:notice("Ceci est un message de journalisation de niveau notice")
        r:warn("Ceci est un message de journalisation de niveau warn")
        r:err("Ceci est un message de journalisation de niveau err")
        r:alert("Ceci est un message de journalisation de niveau alert")
        r:crit("Ceci est un message de journalisation de niveau crit")
        r:emerg("Ceci est un message de journalisation de niveau emerg")</pre>


</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="apache2" id="apache2">Paquet apache2</a></h2>
<p>Le paquet nommé <code>apache2</code> est fourni avec (au minimum) le
contenu suivant :</p>
<dl>
  <dt>apache2.OK</dt>
  <dd>Constante interne OK. Les gestionnaires renverront cette valeur
  s'ils ont traité la requête.</dd>
  <dt>apache2.DECLINED</dt>
  <dd>Constante interne DECLINED. Les gestionnaires renverront cette
  valeur s'ils n'ont pas l'intention de traiter la requête.</dd>
  <dt>apache2.DONE</dt>
  <dd>Constante interne DONE.</dd>
  <dt>apache2.version</dt>
  <dd>Chaîne contenant la version du serveur HTTP Apache</dd>
  <dt>apache2.HTTP_MOVED_TEMPORARILY</dt>
  <dd>Code d'état HTTP</dd>
  <dt>apache2.PROXYREQ_NONE, apache2.PROXYREQ_PROXY, apache2.PROXYREQ_REVERSE, apache2.PROXYREQ_RESPONSE</dt>
  <dd>Constantes internes utilisées par <code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code></dd>
  <dt>apache2.AUTHZ_DENIED, apache2.AUTHZ_GRANTED, apache2.AUTHZ_NEUTRAL, apache2.AUTHZ_GENERAL_ERROR, apache2.AUTHZ_DENIED_NO_USER</dt>
  <dd>constantes internes utilisées par <code class="module"><a href="../mod/mod_authz_core.html">mod_authz_core</a></code></dd>

</dl>
<p>Les autres codes d'état HTTP ne sont pas encore implémentés.</p>
</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="modifying_buckets" id="modifying_buckets">Modification de contenu avec les filtres lua</a></h2>
    
    <p>
    Les fonctions de filtrage implémentées via les directives <code class="directive"><a href="#luainputfilter">LuaInputFilter</a></code> ou <code class="directive"><a href="#luaoutputfilter">LuaOutputFilter</a></code> sont conçues comme des
    fonctions de 3ème phase non blocantes utilisant des sous-routines
    pour suspendre et reprendre l'exécution d'une fonction lorsque des
    paquets de données sont envoyés à la chaîne de filtrage. La
    structure de base d'une telle fonction est :
    </p>
    <pre class="prettyprint lang-lua">function filter(r)
    -- Nous indiquons tout d'abord que nous sommes prêts à recevoir des
    -- blocs de données.
    -- Avant ceci, nous pouvons définir notre environnement, tester
    -- certaines conditions, et, si nous le jugeons nécessaire, refuser le
    -- filtrage d'une requête :
    if something_bad then
        return -- Le filtrage est sauté
    end
    -- Sans se préoccuper des données que nous devons éventuellement ajouter, un arrêt est réalisé ici.
    -- Noter que les filtres de sortie sont les seuls capables d'ajouter des éléments au début des données.
    -- Les filtres en entrée peuvent ajouter des éléments à la fin des données au stade final.

    coroutine.yield([optional header to be prepended to the content])

    -- Après cet arrêt, nous allons recevoir d'autres blocs de données, un par un ;
    -- nous pouvons les traiter comme il nous plaît et procéder à la réponse.
    -- Ces blocs sont conservés dans la variable globale 'bucket', nous réalisons donc
    -- une boucle pour vérifier que 'bucket' n'est pas vide :
    while bucket ~= nil do
        local output = mangle(bucket) -- Do some stuff to the content
        coroutine.yield(output) -- Return our new content to the filter chain
    end

    -- Une fois les blocs de données épuisés, 'bucket' est positionné à une valeur vide ('nil'),
    -- ce qui va nous faire sortir de cette boucle et nous amener à l'étape suivante.
    -- On peut ajouter ce qu'on veut à la fin des données à cette étape, qui constitue le dernier
    -- arrêt. Les filtres d'entrée comme de sortie peuvent servir à ajouter des éléments à la fin
    --  des données à cette étape.
    coroutine.yield([optional footer to be appended to the content])
end</pre>

</div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="databases" id="databases">Connectivité aux bases de données</a></h2>
    
    <p>Mod_lua implémente une fonctionnalité basique de connexion aux
bases de données permettant d'envoyer des requêtes ou d'exécuter des
commandes auprès des moteurs de base de données les plus courants
(mySQL, PostgreSQL, FreeTDS, ODBC, SQLite, Oracle), ainsi que mod_dbd.
    </p>
    <p>L'exemple suivant montre comment se connecter à une base de
données et extraire des informations d'une table :</p>
    <pre class="prettyprint lang-lua">function handle(r)
    -- connexion à la base de données
    local database, err = r:dbacquire("mysql", "server=localhost,user=someuser,pass=somepass,dbname=mydb")
    if not err then
        -- Sélection de certaines informations
        local results, err = database:select(r, "SELECT `name`, `age` FROM `people` WHERE 1")
        if not err then
            local rows = results(0) -- extrait tous les enregistrements en mode synchrone
            for k, row in pairs(rows) do
                r:puts( string.format("Name: %s, Age: %s&lt;br/&gt;", row[1], row[2]) )
            end
        else
            r:puts("Database query error: " .. err)
        end
        database:close()
    else
        r:puts("Connexion à la base de données impossible : " .. err)
    end
end</pre>

    <p>
    Pour utiliser <code class="module"><a href="../mod/mod_dbd.html">mod_dbd</a></code>, spécifiez
<code>mod_dbd</code> comme type de base de données, ou laissez le champ
vide :
    </p>
    <pre class="prettyprint lang-lua">local database = r:dbacquire("mod_dbd")</pre>

    <h3><a name="database_object" id="database_object">L'objet database et ses méthodes</a></h3>
        
        <p>L'objet database renvoyé par <code>dbacquire</code> possède
les méthodes suivantes :</p>
        <p><strong>Sélection normale et requête vers une base de données
:</strong></p>
    <pre class="prettyprint lang-lua">-- Exécution d'une requête et renvoie du nombre d'enregistrements
affectés :
local affected, errmsg = database:query(r, "DELETE FROM `tbl` WHERE 1")

-- Exécution d'une requête et renvoie du résultat qui peut être utilisé
en mode synchrone ou asynchrone :
local result, errmsg = database:select(r, "SELECT * FROM `people` WHERE 1")</pre>

        <p><strong>Utilisation de requêtes préparées (recommandé) :</strong></p>
    <pre class="prettyprint lang-lua">-- Création et exécution d'une requête préparée :
local statement, errmsg = database:prepare(r, "DELETE FROM `tbl` WHERE `age` &gt; %u")
if not errmsg then
    local result, errmsg = statement:query(20) -- exécute la requête pour age &gt; 20
end

-- Extrait une requête préparée depuis une directive DBDPrepareSQL :
local statement, errmsg = database:prepared(r, "someTag")
if not errmsg then
    local result, errmsg = statement:select("John Doe", 123) -- injecte les valeurs "John Doe" et 123 dans la requête
end</pre>

        <p><strong>Echappement de valeurs, fermeture de la base données,
etc...</strong></p>
    <pre class="prettyprint lang-lua">-- Echappe une valeur pour pouvoir l'utiliser dans une requête :
local escaped = database:escape(r, [["'|blabla]])

-- Ferme une base de données et libère les liens vers cette dernière :
database:close()

-- Vérifie si une connexion à une base de données est en service et
opérationnelle :
local connected = database:active()</pre>

    
    <h3><a name="result_sets" id="result_sets">Travail avec les jeux d'enregistrements renvoyés par les requêtes</a></h3>
    
    <p>Les jeux d'enregistrements renvoyés par <code>db:select</code> ou par des
requêtes préparées créées par <code>db:prepare</code> permettent de
sélectionner des enregistrements en mode synchrone ou
asynchrone, selon le nombre d'enregistrements spécifié :<br />
    <code>result(0)</code> sélectionne tous les enregistrements en mode
synchrone en renvoyant une table d'enregistrements.<br />
    <code>result(-1)</code> sélectionne le prochain enregistrement disponible en
mode asynchrone.<br />
    <code>result(N)</code> sélectionne l'enregistrement numéro
<code>N</code> en mode asynchrone.
    </p>
    <pre class="prettyprint lang-lua">-- extrait un jeu d'enregistrements via une requête régulière :
local result, err = db:select(r, "SELECT * FROM `tbl` WHERE 1")

local rows = result(0) -- sélectionne tous les enregistrements en mode synchrone
local row = result(-1) -- sélectionne le prochain enregistrement disponible en mode asynchrone
local row = result(1234) -- sélectionne l'enregistrement 1234 en mode asynchrone
local row = result(-1, true) -- Lit l'enregistrement suivant en utilisant les noms d'enregistrements comme index.</pre>

    <p>Il est possible de construire une fonction qui renvoie une
fonction itérative permettant de traiter tous les enregistrement en mode
synchrone ou asynchrone selon la valeur de l'argument async :
    </p>
    <pre class="prettyprint lang-lua">function rows(resultset, async)
    local a = 0
    local function getnext()
        a = a + 1
        local row = resultset(-1)
        return row and a or nil, row
    end
    if not async then
        return pairs(resultset(0))
    else
        return getnext, self
    end
end

local statement, err = db:prepare(r, "SELECT * FROM `tbl` WHERE `age` &gt; %u")
if not err then
     -- sélectionne des enregistrements en mode asynchrone :
    local result, err = statement:select(20)
    if not err then
        for index, row in rows(result, true) do
            ....
        end
    end

     -- sélectionne des enregistrements en mode synchrone :
    local result, err = statement:select(20)
    if not err then
        for index, row in rows(result, false) do
            ....
        end
    end
end</pre>

    
    <h3><a name="closing_databases" id="closing_databases">Fermeture d'une connexion à une base de données</a></h3>
        

    <p>Lorsqu'elles ne sont plus utilisées, les connexions aux bases de
données doivent être fermées avec <code>database:close()</code>. Si vous
ne les fermez pas manuellement, mod_lua les fermera peut-être en tant
que résidus collectés, mais si ce n'est pas le cas, vous pouvez finir
pas avoir trop de connexions vers la base de données inutilisées. Les
deux mesures suivantes sont pratiquement identiques :
    </p>
    <pre class="prettyprint lang-lua">-- Méthode 1 : fermeture manuelle de la connexion
local database = r:dbacquire("mod_dbd")
database:close() -- c'est tout

-- Méthode 2 : on laisse le collecteur de résidus la fermer
local database = r:dbacquire("mod_dbd")
database = nil -- on coupe le lien
collectgarbage() -- fermeture de la connexion par le collecteur de résidus</pre>

    
    <h3><a name="database_caveat" id="database_caveat">Précautions à prendre lorsque l'on travaille avec les bases
de données</a></h3>
    
    <p>Bien que les fonctions <code>query</code> et <code>run</code>
soient toujours disponibles, il est recommandé d'utiliser des requêtes
préparées chaque fois que possible, afin d'une part d'optimiser les
performances (si votre connexion reste longtemps en vie), et d'autre part
minimiser le risque d'attaques par injection SQL. Les fonctions
<code>run</code> et <code>query</code> ne doivent être utilisées que
lorsque la requête ne contient pas de variables (requête statique). Dans
le cas des requêtes dynamiques, utilisez <code>db:prepare</code> ou
<code>db:prepared</code>.
    </p>
    

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luaauthzprovider" id="luaauthzprovider">Directive</a> <a name="LuaAuthzProvider" id="LuaAuthzProvider">LuaAuthzProvider</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Plug an authorization provider function into <code class="module"><a href="../mod/mod_authz_core.html">mod_authz_core</a></code>
</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaAuthzProvider provider_name /path/to/lua/script.lua function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">Compatibilité:</a></th><td>2.4.3 and later</td></tr>
</table>
<p>After a lua function has been registered as authorization provider, it can be used
with the <code class="directive"><a href="../mod/mod_authz_core.html#require">Require</a></code> directive:</p>

<pre class="prettyprint lang-config">LuaRoot /usr/local/apache2/lua
LuaAuthzProvider foo authz.lua authz_check_foo
&lt;Location "/"&gt;
  Require foo johndoe
&lt;/Location&gt;</pre>

<pre class="prettyprint lang-lua">require "apache2"
function authz_check_foo(r, who)
    if r.user ~= who then return apache2.AUTHZ_DENIED
    return apache2.AUTHZ_GRANTED
end</pre>




</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luacodecache" id="luacodecache">Directive</a> <a name="LuaCodeCache" id="LuaCodeCache">LuaCodeCache</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Configure the compiled code cache.</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaCodeCache stat|forever|never</code></td></tr>
<tr><th><a href="directive-dict.html#Default">Défaut:</a></th><td><code>LuaCodeCache stat</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table><p>
    Specify the behavior of the in-memory code cache. The default
    is stat, which stats the top level script (not any included
    ones) each time that file is needed, and reloads it if the
    modified time indicates it is newer than the one it has
    already loaded. The other values cause it to keep the file
    cached forever (don't stat and replace) or to never cache the
    file.</p>

    <p>In general stat or forever is good for production, and stat or never
    for development.</p>

    <div class="example"><h3>Examples:</h3><pre class="prettyprint lang-config">LuaCodeCache stat
LuaCodeCache forever
LuaCodeCache never</pre>
</div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahookaccesschecker" id="luahookaccesschecker">Directive</a> <a name="LuaHookAccessChecker" id="LuaHookAccessChecker">LuaHookAccessChecker</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the access_checker phase of request processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookAccessChecker  /path/to/lua/script.lua  hook_function_name [early|late]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">Compatibilité:</a></th><td>The optional third argument is supported in 2.3.15 and later</td></tr>
</table>
<p>Add your hook to the access_checker phase.  An access checker
hook function usually returns OK, DECLINED, or HTTP_FORBIDDEN.</p>
   <div class="note"><h3>Ordering</h3><p>The optional arguments "early" or "late"
   control when this script runs relative to other modules.</p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahookauthchecker" id="luahookauthchecker">Directive</a> <a name="LuaHookAuthChecker" id="LuaHookAuthChecker">LuaHookAuthChecker</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the auth_checker phase of request processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookAuthChecker  /path/to/lua/script.lua hook_function_name [early|late]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">Compatibilité:</a></th><td>The optional third argument is supported in 2.3.15 and later</td></tr>
</table>
<p>Invoke a lua function in the auth_checker phase of processing
a request.  This can be used to implement arbitrary authentication
and authorization checking.  A very simple example:
</p>
<pre class="prettyprint lang-lua">require 'apache2'

-- fake authcheck hook
-- If request has no auth info, set the response header and
-- return a 401 to ask the browser for basic auth info.
-- If request has auth info, don't actually look at it, just
-- pretend we got userid 'foo' and validated it.
-- Then check if the userid is 'foo' and accept the request.
function authcheck_hook(r)

   -- look for auth info
   auth = r.headers_in['Authorization']
   if auth ~= nil then
     -- fake the user
     r.user = 'foo'
   end

   if r.user == nil then
      r:debug("authcheck: user is nil, returning 401")
      r.err_headers_out['WWW-Authenticate'] = 'Basic realm="WallyWorld"'
      return 401
   elseif r.user == "foo" then
      r:debug('user foo: OK')
   else
      r:debug("authcheck: user='" .. r.user .. "'")
      r.err_headers_out['WWW-Authenticate'] = 'Basic realm="WallyWorld"'
      return 401
   end
   return apache2.OK
end</pre>

   <div class="note"><h3>Ordering</h3><p>The optional arguments "early" or "late"
   control when this script runs relative to other modules.</p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahookcheckuserid" id="luahookcheckuserid">Directive</a> <a name="LuaHookCheckUserID" id="LuaHookCheckUserID">LuaHookCheckUserID</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the check_user_id phase of request processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookCheckUserID  /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahookfixups" id="luahookfixups">Directive</a> <a name="LuaHookFixups" id="LuaHookFixups">LuaHookFixups</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the fixups phase of a request
processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookFixups  /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
<p>
    Just like LuaHookTranslateName, but executed at the fixups phase
</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahookinsertfilter" id="luahookinsertfilter">Directive</a> <a name="LuaHookInsertFilter" id="LuaHookInsertFilter">LuaHookInsertFilter</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the insert_filter phase of request processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookInsertFilter  /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table><p>Not Yet Implemented</p>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahooklog" id="luahooklog">Directive</a> <a name="LuaHookLog" id="LuaHookLog">LuaHookLog</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the access log phase of a request
processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookLog  /path/to/lua/script.lua log_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
<p>
    This simple logging hook allows you to run a function when httpd enters the
    logging phase of a request. With it, you can append data to your own logs,
    manipulate data before the regular log is written, or prevent a log entry
    from being created. To prevent the usual logging from happening, simply return
    <code>apache2.DONE</code> in your logging handler, otherwise return
    <code>apache2.OK</code> to tell httpd to log as normal.
</p>
<p>Example:</p>
<pre class="prettyprint lang-config">LuaHookLog /path/to/script.lua logger</pre>

<pre class="prettyprint lang-lua">-- /path/to/script.lua --
function logger(r)
    -- flip a coin:
    -- If 1, then we write to our own Lua log and tell httpd not to log
    -- in the main log.
    -- If 2, then we just sanitize the output a bit and tell httpd to
    -- log the sanitized bits.

    if math.random(1,2) == 1 then
        -- Log stuff ourselves and don't log in the regular log
        local f = io.open("/foo/secret.log", "a")
        if f then
            f:write("Something secret happened at " .. r.uri .. "\n")
            f:close()
        end
        return apache2.DONE -- Tell httpd not to use the regular logging functions
    else
        r.uri = r.uri:gsub("somesecretstuff", "") -- sanitize the URI
        return apache2.OK -- tell httpd to log it.
    end
end</pre>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahookmaptostorage" id="luahookmaptostorage">Directive</a> <a name="LuaHookMapToStorage" id="LuaHookMapToStorage">LuaHookMapToStorage</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the map_to_storage phase of request processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookMapToStorage  /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
    <p>Like <code class="directive">LuaHookTranslateName</code> but executed at the
    map-to-storage phase of a request. Modules like mod_cache run at this phase,
    which makes for an interesting example on what to do here:</p>
    <pre class="prettyprint lang-config">LuaHookMapToStorage /path/to/lua/script.lua check_cache</pre>

    <pre class="prettyprint lang-lua">require"apache2"
cached_files = {}

function read_file(filename)
    local input = io.open(filename, "r")
    if input then
        local data = input:read("*a")
        cached_files[filename] = data
        file = cached_files[filename]
        input:close()
    end
    return cached_files[filename]
end

function check_cache(r)
    if r.filename:match("%.png$") then -- Only match PNG files
        local file = cached_files[r.filename] -- Check cache entries
        if not file then
            file = read_file(r.filename)  -- Read file into cache
        end
        if file then -- If file exists, write it out
            r.status = 200
            r:write(file)
            r:info(("Sent %s to client from cache"):format(r.filename))
            return apache2.DONE -- skip default handler for PNG files
        end
    end
    return apache2.DECLINED -- If we had nothing to do, let others serve this.
end</pre>


    
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahooktranslatename" id="luahooktranslatename">Directive</a> <a name="LuaHookTranslateName" id="LuaHookTranslateName">LuaHookTranslateName</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the translate name phase of request processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookTranslateName  /path/to/lua/script.lua  hook_function_name [early|late]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">Compatibilité:</a></th><td>The optional third argument is supported in 2.3.15 and later</td></tr>
</table><p>
    Add a hook (at APR_HOOK_MIDDLE) to the translate name phase of
    request processing. The hook function receives a single
    argument, the request_rec, and should return a status code,
    which is either an HTTP error code, or the constants defined
    in the apache2 module: apache2.OK, apache2.DECLINED, or
    apache2.DONE. </p>

    <p>For those new to hooks, basically each hook will be invoked
    until one of them returns apache2.OK. If your hook doesn't
    want to do the translation it should just return
    apache2.DECLINED. If the request should stop processing, then
    return apache2.DONE.</p>

    <p>Example:</p>

<pre class="prettyprint lang-config"># httpd.conf
LuaHookTranslateName /scripts/conf/hooks.lua silly_mapper</pre>


<pre class="prettyprint lang-lua">-- /scripts/conf/hooks.lua --
require "apache2"
function silly_mapper(r)
    if r.uri == "/" then
        r.filename = "/var/www/home.lua"
        return apache2.OK
    else
        return apache2.DECLINED
    end
end</pre>


   <div class="note"><h3>Context</h3><p>This directive is not valid in <code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code>, <code class="directive"><a href="../mod/core.html#files">&lt;Files&gt;</a></code>, or htaccess
   context.</p></div>

   <div class="note"><h3>Ordering</h3><p>The optional arguments "early" or "late"
   control when this script runs relative to other modules.</p></div>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luahooktypechecker" id="luahooktypechecker">Directive</a> <a name="LuaHookTypeChecker" id="LuaHookTypeChecker">LuaHookTypeChecker</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the type_checker phase of request processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaHookTypeChecker  /path/to/lua/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table><p>
    This directive provides a hook for the type_checker phase of the request processing.
    This phase is where requests are assigned a content type and a handler, and thus can
    be used to modify the type and handler based on input:
    </p>
    <pre class="prettyprint lang-config">LuaHookTypeChecker /path/to/lua/script.lua type_checker</pre>

    <pre class="prettyprint lang-lua">    function type_checker(r)
        if r.uri:match("%.to_gif$") then -- match foo.png.to_gif
            r.content_type = "image/gif" -- assign it the image/gif type
            r.handler = "gifWizard"      -- tell the gifWizard module to handle this
            r.filename = r.uri:gsub("%.to_gif$", "") -- fix the filename requested
            return apache2.OK
        end

        return apache2.DECLINED
    end</pre>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luainherit" id="luainherit">Directive</a> <a name="LuaInherit" id="LuaInherit">LuaInherit</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Controls how parent configuration sections are merged into children</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaInherit none|parent-first|parent-last</code></td></tr>
<tr><th><a href="directive-dict.html#Default">Défaut:</a></th><td><code>LuaInherit parent-first</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">Compatibilité:</a></th><td>2.4.0 and later</td></tr>
</table><p>By default, if LuaHook* directives are used in overlapping
    Directory or Location configuration sections, the scripts defined in the
    more specific section are run <em>after</em> those defined in the more
    generic section (LuaInherit parent-first).  You can reverse this order, or
    make the parent context not apply at all.</p>

    <p> In previous 2.3.x releases, the default was effectively to ignore LuaHook*
    directives from parent configuration sections.</p>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luainputfilter" id="luainputfilter">Directive</a> <a name="LuaInputFilter" id="LuaInputFilter">LuaInputFilter</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a Lua function for content input filtering</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaInputFilter filter_name /path/to/lua/script.lua function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">Compatibilité:</a></th><td>2.4.5 and later</td></tr>
</table>
<p>Provides a means of adding a Lua function as an input filter.
As with output filters, input filters work as coroutines,
first yielding before buffers are sent, then yielding whenever
a bucket needs to be passed down the chain, and finally (optionally)
yielding anything that needs to be appended to the input data. The
global variable <code>bucket</code> holds the buckets as they are passed
onto the Lua script:
</p>

<pre class="prettyprint lang-config">LuaInputFilter myInputFilter /www/filter.lua input_filter
&lt;Files "*.lua"&gt;
  SetInputFilter myInputFilter
&lt;/Files&gt;</pre>

<pre class="prettyprint lang-lua">--[[
    Example input filter that converts all POST data to uppercase.
]]--
function input_filter(r)
    print("luaInputFilter called") -- debug print
    coroutine.yield() -- Yield and wait for buckets
    while bucket do -- For each bucket, do...
        local output = string.upper(bucket) -- Convert all POST data to uppercase
        coroutine.yield(output) -- Send converted data down the chain
    end
    -- No more buckets available.
    coroutine.yield("&amp;filterSignature=1234") -- Append signature at the end
end</pre>

<p>
The input filter supports denying/skipping a filter if it is deemed unwanted:
</p>
<pre class="prettyprint lang-lua">function input_filter(r)
    if not good then
        return -- Simply deny filtering, passing on the original content instead
    end
    coroutine.yield() -- wait for buckets
    ... -- insert filter stuff here
end</pre>

<p>
See "<a href="#modifying_buckets">Modifying contents with Lua
filters</a>" for more information.
</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luamaphandler" id="luamaphandler">Directive</a> <a name="LuaMapHandler" id="LuaMapHandler">LuaMapHandler</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Map a path to a lua handler</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaMapHandler uri-pattern /path/to/lua/script.lua [function-name]</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
    <p>This directive matches a uri pattern to invoke a specific
    handler function in a specific file. It uses PCRE regular
    expressions to match the uri, and supports interpolating
    match groups into both the file path and the function name.
    Be careful writing your regular expressions to avoid security
    issues.</p>
   <div class="example"><h3>Examples:</h3><pre class="prettyprint lang-config">LuaMapHandler /(\w+)/(\w+) /scripts/$1.lua handle_$2</pre>
</div>
        <p>This would match uri's such as /photos/show?id=9
        to the file /scripts/photos.lua and invoke the
        handler function handle_show on the lua vm after
        loading that file.</p>

<pre class="prettyprint lang-config">LuaMapHandler /bingo /scripts/wombat.lua</pre>

        <p>This would invoke the "handle" function, which
        is the default if no specific function name is
        provided.</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luaoutputfilter" id="luaoutputfilter">Directive</a> <a name="LuaOutputFilter" id="LuaOutputFilter">LuaOutputFilter</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a Lua function for content output filtering</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaOutputFilter filter_name /path/to/lua/script.lua function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
<tr><th><a href="directive-dict.html#Compatibility">Compatibilité:</a></th><td>2.4.5 and later</td></tr>
</table>
<p>Provides a means of adding a Lua function as an output filter.
As with input filters, output filters work as coroutines,
first yielding before buffers are sent, then yielding whenever
a bucket needs to be passed down the chain, and finally (optionally)
yielding anything that needs to be appended to the input data. The
global variable <code>bucket</code> holds the buckets as they are passed
onto the Lua script:
</p>

<pre class="prettyprint lang-config">LuaOutputFilter myOutputFilter /www/filter.lua output_filter
&lt;Files "*.lua"&gt;
  SetOutputFilter myOutputFilter
&lt;/Files&gt;</pre>

<pre class="prettyprint lang-lua">--[[
    Example output filter that escapes all HTML entities in the output
]]--
function output_filter(r)
    coroutine.yield("(Handled by myOutputFilter)&lt;br/&gt;\n") -- Prepend some data to the output,
                                                          -- yield and wait for buckets.
    while bucket do -- For each bucket, do...
        local output = r:escape_html(bucket) -- Escape all output
        coroutine.yield(output) -- Send converted data down the chain
    end
    -- No more buckets available.
end</pre>

<p>
As with the input filter, the output filter supports denying/skipping a filter
if it is deemed unwanted:
</p>
<pre class="prettyprint lang-lua">function output_filter(r)
    if not r.content_type:match("text/html") then
        return -- Simply deny filtering, passing on the original content instead
    end
    coroutine.yield() -- wait for buckets
    ... -- insert filter stuff here
end</pre>

<div class="note"><h3>Lua filters with <code class="module"><a href="../mod/mod_filter.html">mod_filter</a></code></h3>
<p> When a Lua filter is used as the underlying provider via the
<code class="directive"><a href="../mod/mod_filter.html#filterprovider">FilterProvider</a></code> directive, filtering
will only work when the <var>filter-name</var> is identical to the <var>provider-name</var>.
</p> </div>

<p>
See "<a href="#modifying_buckets">Modifying contents with Lua filters</a>" for more
information.
</p>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luapackagecpath" id="luapackagecpath">Directive</a> <a name="LuaPackageCPath" id="LuaPackageCPath">LuaPackageCPath</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Add a directory to lua's package.cpath</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaPackageCPath /path/to/include/?.soa</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
    <p>Add a path to lua's shared library search path. Follows the same
    conventions as lua. This just munges the package.cpath in the
    lua vms.</p>


</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luapackagepath" id="luapackagepath">Directive</a> <a name="LuaPackagePath" id="LuaPackagePath">LuaPackagePath</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Add a directory to lua's package.path</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaPackagePath /path/to/include/?.lua</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table><p>Add a path to lua's module search path. Follows the same
    conventions as lua. This just munges the package.path in the
    lua vms.</p>

    <div class="example"><h3>Examples:</h3><pre class="prettyprint lang-config">LuaPackagePath /scripts/lib/?.lua
LuaPackagePath /scripts/lib/?/init.lua</pre>
</div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luaquickhandler" id="luaquickhandler">Directive</a> <a name="LuaQuickHandler" id="LuaQuickHandler">LuaQuickHandler</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Provide a hook for the quick handler of request processing</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaQuickHandler /path/to/script.lua hook_function_name</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
    <p>
    This phase is run immediately after the request has been mapped to a virtal host,
    and can be used to either do some request processing before the other phases kick
    in, or to serve a request without the need to translate, map to storage et cetera.
    As this phase is run before anything else, directives such as <code class="directive"><a href="../mod/core.html#location">&lt;Location&gt;</a></code> or <code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code> are void in this phase, just as
    URIs have not been properly parsed yet.
    </p>
   <div class="note"><h3>Context</h3><p>This directive is not valid in <code class="directive"><a href="../mod/core.html#directory">&lt;Directory&gt;</a></code>, <code class="directive"><a href="../mod/core.html#files">&lt;Files&gt;</a></code>, or htaccess
   context.</p></div>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luaroot" id="luaroot">Directive</a> <a name="LuaRoot" id="LuaRoot">LuaRoot</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>Specify the base path for resolving relative paths for mod_lua directives</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaRoot /path/to/a/directory</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
    <p>Specify the base path which will be used to evaluate all
    relative paths within mod_lua. If not specified they
    will be resolved relative to the current working directory,
    which may not always work well for a server.</p>

</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="directive-section"><h2><a name="luascope" id="luascope">Directive</a> <a name="LuaScope" id="LuaScope">LuaScope</a></h2>
<table class="directive">
<tr><th><a href="directive-dict.html#Description">Description:</a></th><td>One of once, request, conn, thread -- default is once</td></tr>
<tr><th><a href="directive-dict.html#Syntax">Syntaxe:</a></th><td><code>LuaScope once|request|conn|thread|server [min] [max]</code></td></tr>
<tr><th><a href="directive-dict.html#Default">Défaut:</a></th><td><code>LuaScope once</code></td></tr>
<tr><th><a href="directive-dict.html#Context">Contexte:</a></th><td>configuration du serveur, serveur virtuel, répertoire, .htaccess</td></tr>
<tr><th><a href="directive-dict.html#Override">AllowOverride:</a></th><td>All</td></tr>
<tr><th><a href="directive-dict.html#Status">Statut:</a></th><td>Expérimental</td></tr>
<tr><th><a href="directive-dict.html#Module">Module:</a></th><td>mod_lua</td></tr>
</table>
    <p>Specify the life cycle scope of the Lua interpreter which will
    be used by handlers in this "Directory." The default is "once"</p>

   <dl>
    <dt>once:</dt> <dd>use the interpreter once and throw it away.</dd>

    <dt>request:</dt> <dd>use the interpreter to handle anything based on
             the same file within this request, which is also
             request scoped.</dd>

    <dt>conn:</dt> <dd>Same as request but attached to the connection_rec</dd>

    <dt>thread:</dt> <dd>Use the interpreter for the lifetime of the thread
            handling the request (only available with threaded MPMs).</dd>

    <dt>server:</dt>  <dd>This one is different than others because the
            server scope is quite long lived, and multiple threads
            will have the same server_rec. To accommodate this,
            server scoped Lua states are stored in an apr
            resource list. The <code>min</code> and <code>max</code> arguments
            specify the minimum and maximum number of Lua states to keep in the
            pool.</dd>
   </dl>
    <p>
    Generally speaking, the <code>thread</code> and <code>server</code> scopes
    execute roughly 2-3 times faster than the rest, because they don't have to
    spawn new Lua states on every request (especially with the event MPM, as
    even keepalive requests will use a new thread for each request). If you are
    satisfied that your scripts will not have problems reusing a state, then
    the <code>thread</code> or <code>server</code> scopes should be used for
    maximum performance. While the <code>thread</code> scope will provide the
    fastest responses, the <code>server</code> scope will use less memory, as
    states are pooled, allowing f.x. 1000 threads to share only 100 Lua states,
    thus using only 10% of the memory required by the <code>thread</code> scope.
    </p>

</div>
</div>
<div class="bottomlang">
<p><span>Langues Disponibles: </span><a href="../en/mod/mod_lua.html" hreflang="en" rel="alternate" title="English">&nbsp;en&nbsp;</a> |
<a href="../fr/mod/mod_lua.html" title="Français">&nbsp;fr&nbsp;</a></p>
</div><div class="top"><a href="#page-header"><img src="../images/up.gif" alt="top" /></a></div><div class="section"><h2><a id="comments_section" name="comments_section">Commentaires</a></h2><div class="warning"><strong>Notice:</strong><br />This is not a Q&amp;A section. Comments placed here should be pointed towards suggestions on improving the documentation or server, and may be removed again by our moderators if they are either implemented or considered invalid/off-topic. Questions on how to manage the Apache HTTP Server should be directed at either our IRC channel, #httpd, on Freenode, or sent to our <a href="http://httpd.apache.org/lists.html">mailing lists</a>.</div>
<script type="text/javascript"><!--//--><![CDATA[//><!--
var comments_shortname = 'httpd';
var comments_identifier = 'http://httpd.apache.org/docs/trunk/mod/mod_lua.html';
(function(w, d) {
    if (w.location.hostname.toLowerCase() == "httpd.apache.org") {
        d.write('<div id="comments_thread"><\/div>');
        var s = d.createElement('script');
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'https://comments.apache.org/show_comments.lua?site=' + comments_shortname + '&page=' + comments_identifier;
        (d.getElementsByTagName('head')[0] || d.getElementsByTagName('body')[0]).appendChild(s);
    }
    else {
        d.write('<div id="comments_thread">Comments are disabled for this page at the moment.<\/div>');
    }
})(window, document);
//--><!]]></script></div><div id="footer">
<p class="apache">Copyright 2017 The Apache Software Foundation.<br />Autorisé sous <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.</p>
<p class="menu"><a href="../mod/">Modules</a> | <a href="../mod/quickreference.html">Directives</a> | <a href="http://wiki.apache.org/httpd/FAQ">FAQ</a> | <a href="../glossary.html">Glossaire</a> | <a href="../sitemap.html">Plan du site</a></p></div><script type="text/javascript"><!--//--><![CDATA[//><!--
if (typeof(prettyPrint) !== 'undefined') {
    prettyPrint();
}
//--><!]]></script>
</body></html>