<?xml version="1.0"?>
<!DOCTYPE modulesynopsis SYSTEM "../style/modulesynopsis.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.tr.xsl"?>
<!-- English Revision: 1147342 -->
<!-- =====================================================
 Translated by: Nilgün Belma Bugüner <nilgun belgeler.org>
   Reviewed by: Orhan Berent <berent belgeler.org>
========================================================== -->

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<modulesynopsis metafile="mod_alias.xml.meta">

<name>mod_alias</name>
<description>Belge ağacının parçalarının dosya sisteminin parçalarıyla
eşlenmesini sağlar ve URL yönlendirmesi yapar.</description>
<status>Base</status>
<sourcefile>mod_alias.c</sourcefile>
<identifier>alias_module</identifier>

  <summary>
    <p>Bu modülde bulunan yönergeler sunucuya istek olarak gelen URL’lerin
      denetlenmesini ve değiştirilmesini mümkün kılar. <directive
      module="mod_alias" >Alias</directive> ve <directive module="mod_alias"
      >ScriptAlias</directive> yönergeleri URL’lerin dosya sisteminin
      dizinlerine eşlenmesini sağlar. Böylece, kök dizini <directive
      module="core">DocumentRoot</directive> ile belirtilen site belge ağacı
      altında bulunmayan içeriğe erişmek mümkün olur. <directive
      module="mod_alias" >ScriptAlias</directive> yönergesi buna ek olarak
      hedef dizini sadece CGI betiklerini içeren dizin olarak imler.</p>

    <p><directive module="mod_alias">Redirect</directive> yönergesi,
      farklı bir URL ile yeni bir istek yapmaları için istemcileri
      yönlendirmekte kullanılır. Çoğunlukla özkaynak başka bir yere
      taşındığında kullanılır.</p>

    <p><module>mod_alias</module> modülü basit URL değiştirme görevlerini
      yerine getirmek için tasarlanmıştır. Sorgu dizgelerini işleme sokmak
      gibi daha karmaşık görevler için <module>mod_rewrite</module> modülü ile
      sağlanan araçlar kullanılır.</p>

  </summary>

  <seealso><module>mod_rewrite</module></seealso> <seealso><a
    href="../urlmapping.html">URL’lerin Dosya sistemi ile Eşlenmesi</a>
  </seealso>

  <section id="order"><title>İşlem Sırası</title>

    <p>Farklı bağlamlarda bulunan <directive module="mod_alias"
      >Alias</directive> ve <directive module="mod_alias">Redirect</directive>
      yönergeleri standart <a href="../sections.html#mergin">katıştırma
      kuralları</a> ile ilgili diğer yönergeler gibi işleme sokulur. Fakat
      aynı bağlam dahilinde (örneğin, aynı <directive type="section"
      module="core">VirtualHost</directive> bölümünde) çok fazla <directive
      module="mod_alias" >Alias</directive> ve <directive
      module="mod_alias">Redirect</directive> varsa bunlar belli bir
      sıraya göre işleme sokulurlar.</p>

    <p>İlk adımda, <directive module="mod_alias">Alias</directive>’lardan önce
      bütün <directive module="mod_alias">Redirect</directive> yönergeleri
      işleme sokulur. Bu bakımdan bir <directive module="mod_alias"
      >Redirect</directive> veya <directive module="mod_alias"
      >RedirectMatch</directive> ile eşleşen bir istek için
      hiçbir <directive module="mod_alias" >Alias</directive>
      uygulanmayacaktır. İkinci adımda yapılandırma dosyasında yer aldıkları
      sıraya göre <directive module="mod_alias" >Redirect</directive> ve
      <directive module="mod_alias" >Alias</directive> yönergeleri işleme
      sokulurlar, dolayısıyla ilk eşleşme öncelikli olmuş olur.</p>

    <p>İlk eşleşmenin öncelikli olması sebebiyle, bu yönergelerin birden
      fazlası aynı alt yola uygulandığı takdirde, tüm yönergelerin etkili
      olabilmesi için en uzun yolu sıralamada en öne almalısınız. Örneğin
      aşağıdaki yapılandırma beklendiği gibi çalışacaktır:</p>

    <example>
    Alias /foo/bar /baz<br />
    Alias /foo /gaz
    </example>

    <p>Ama yukarıdaki iki satır ters sırada yerleştirilmiş olsaydı,
      <code>/foo</code> rumuzu  daima <code>/foo/bar</code> rumuzundan önce
      eşleşecek, dolayısıyla ikinci yönerge yok sayılacaktı.</p>

  </section>

<directivesynopsis>
<name>Alias</name>
<description>URL’leri dosya sistemi konumlarıyla eşler.</description>
<syntax>Alias <var>URL-yolu</var>
<var>dosya-yolu</var>|<var>dizin-yolu</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

  <usage>

    <p><directive>Alias</directive> yönergesi, belgelerin <directive
      module="core">DocumentRoot</directive> dizininden farklı bir yerde
      saklanmasını mümkün kılar. <code><em>URL-yolu</em></code> ile başlayan
      URL’ler (% imlemesi çözüldükten sonra) <code><em>dizin-yolu</em></code>
      ile başlayan yerel dosyalarla eşlenir. <code><em>URL-yolu</em></code>,
      harf büyüklüğüne duyarsız sistemlerde bile harf büyüklüğüne
      duyarlıdır.</p>

    <example><title>Örnek:</title>
      Alias /image /ftp/pub/image
    </example>

    <p><code>http://mesela.dom/image/foo.gif</code> şeklinde bir istek, sunucunun
      <code>/ftp/pub/image/foo.gif</code> dosyasıyla yanıt vermesine sebep
      olurdu. Sadece tam yol parçaları eşleştirilir; bu bakımdan yukarıdaki
      <directive>Alias</directive> yapılandırması
      <code>http://mesela.dom/imagefoo.gif</code> ile eşleşmez. Düzenli
      ifadelerin kullanıldığı daha karmaşık eşleşmeler için <directive
      module="mod_alias" >AliasMatch</directive> yönergesine bakınız.</p>

    <p><code><em>URL-yolu</em></code>’nu bir <code>/</code> ile
      sonlandırırsanız <directive>Alias</directive> yönergesini yorumlarken
      sunucunun da sona bir <code>/</code> ekleyeceğine dikkat ediniz. Yani,
      eğer</p>

    <dl><dd><code>Alias /icons/ /usr/local/apache/icons/</code></dd></dl>

    <p>diye bir tanım yaparsanız <code>/icons</code> URL’si için, sonunda bir /
      yokmuşçasına bir <directive>Alias</directive> kullanılmayacaktır. Benzer
      şekilde, <var>URL-yolu</var> belirtirken sonda / kullanmazsanız
      <var>dosya-yolu</var> için de sonda / kullanmamalısınız.</p>

    <p><directive>Alias</directive> <em>hedefleri</em> için ek <directive
      type="section" module="core" >Directory</directive> bölümleri
      belirtmeniz gerekebileceğine dikkat ediniz. <directive type="section"
      module="core" >Directory</directive> bölümlerinden önce yer alan
      <directive>Alias</directive> yönergelerine özellikle bakılır,
      dolayısıyla sadece <directive>Alias</directive> hedefleri etkilenir.
      (Bununla birlikte, <directive>Alias</directive> yönergelerinden önce
      işleme sokulan <directive type="section"
      module="core">Location</directive> bölümlerinin uygulanacağına dikkat
      ediniz.)</p>

    <p>Özellikle, <directive module="core">DocumentRoot</directive> dışında
      bir dizine bir <directive>Alias</directive> oluşturuyorsanız hedef
      dizine doğrudan erişim izni vermeniz gerekebilir.</p>

    <example><title>Örnek:</title>
        Alias /image /ftp/pub/image<br />
        &lt;Directory /ftp/pub/image&gt;<br />
        <indent>
            Order allow,deny<br />
            Allow from all<br />
        </indent>
        &lt;/Directory&gt;
    </example>
  </usage>
</directivesynopsis>

<directivesynopsis>
<name>AliasMatch</name>
<description>URL’leri dosya sistemi konumlarıyla düzenli ifadeleri kullanarak
eşler.</description>
<syntax>AliasMatch <var>düzenli-ifade</var>
<var>dosya-yolu</var>|<var>dizin-yolu</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

  <usage>
    <p>Bu yönerge <code><em>URL-yolu</em></code> ile eşleşmek üzere bir
      <glossary ref="regex">düzenli ifade</glossary> kabul etmesi dışında
      <directive module="mod_alias">Alias</directive> yönergesine eşdeğerdir.
      Belirtilen düzenli ifade <code><em>URL-yolu</em></code> ile eşleşiyorsa
      sunucu parantezli eşleşmeleri belirtilen dizgede kullanarak dosya yolunu
      elde eder. Örneğin, <code>/icons</code> dizinini etkinleştirmek için şu
      yazılabilir:</p>

    <example>
      AliasMatch ^/icons(.*) /usr/local/apache/icons$1
    </example>

    <p><glossary ref="regex">Düzenli ifadeler</glossary> tüm gücüyle
      kullanılabilir Örneğin, <code><em>URL-yolu</em></code> ile harf büyüklüğüne
      duyarsız eşleşmeler sağlayacak düzenli ifadeler kullanılabilir:</p>

    <example>
      AliasMatch (?i)^/image(.*) /ftp/pub/image$1
    </example>

    <p><directive module="mod_alias">Alias</directive>
      ile <directive module="mod_alias">AliasMatch</directive> arasındaki
      belirgin tek fark <directive module="mod_alias">Alias</directive>
      yönergesinin URI'nin bir ek bölümünü, sağda, dosya yolunun sonundaki
      eşleşen parçayı özdevinimli olarak kopyalayacak olmasıdır. Halbuki
      <directive module="mod_alias">AliasMatch </directive> bunu yapmaz. Yani,
      hemen her durumda, istek URI'sinin baştan sona tümünün düzenli ifade ile
      eşleşmesini ve sağ taraftaki ikamenin kullanılmasını istersiniz.</p>

    <p>Başka bir deyişle, <directive module="mod_alias">Alias</directive> yerine
      <directive module="mod_alias">AliasMatch</directive> yazmak aynı etkiyi
      sağlamayacaktır. En azından, düzenli ifadenin başına <code>^</code> ve
      sonuna <code>(.*)$</code> ekledikten sonra yer değiştirme parçasının sonuna
      da <code>$1</code> eklemeniz gerekir.</p>

    <p>Örneğin, bunu AliasMatch ile değiştirmek istediğinizi varsayalım:</p>

    <example>
      Alias /image/ /ftp/pub/image/
    </example>

    <p>Bu aynı şey değildir; bunu yapmayın! Bu, herhangi bir yerinde /image/
      içeren tüm istekleri /ftp/pub/image/ dizinine gönderecektir:</p>

    <example>
      AliasMatch /image/ /ftp/pub/image/
    </example>

    <p>Aynı etkiyi elde etmek için yapacağınız bu olacaktır:</p>

    <example>
      AliasMatch ^/image/(.*)$ /ftp/pub/image/$1
    </example>

    <p>Şüphesiz, <directive module="mod_alias">Alias</directive> yönergesinin
      çalıştığı yerde <directive module="mod_alias">AliasMatch</directive>
      kullanmanın bir yararı yoktur. <directive
      module="mod_alias">AliasMatch</directive> daha karmaşık şeyler yapma imkanı
      verir. Örneğin, farklı dizinler altındaki farklı dosyalar için başka
      yerdeki dosyaları sunmak isteyelim:</p>

    <example>
      AliasMatch ^/image/(.*)\.jpg$ /files/jpg.images/$1.jpg<br/>
      AliasMatch ^/image/(.*)\.gif$ /files/gif.images/$1.gif
    </example>
  </usage>
</directivesynopsis>

<directivesynopsis>
<name>Redirect</name>
<description>İstemciyi, bir yönlendirme isteği döndürerek farklı bir URL’ye
yönlendirir.</description>
<syntax>Redirect [<var>durum</var>] <var>URL-yolu</var>
<var>URL</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>FileInfo</override>

  <usage>
    <p><directive>Redirect</directive> yönergesi istemciye bir yönlendirme
      isteği döndürerek eski URL’yi yenisiyle eşler.</p>

    <p>Eski <code><em>URL-yolu</em></code> bir bölü çizgisi ile başlar ve harf
      büyüklüğüne duyarlıdır (% imlemesi çözüldükten sonra).
      <code><em>URL-yolu</em></code> olarak göreli yollara izin verilmez.
      <code><em>URL</em></code> ise ya bir şema ve konak ismi ile başlayan bir
      mutlak URL ya da bir bölü çizgisi ile başlayan bir URL yolu olmalıdır.
      İkinci durumda URL yolunun başına geçerli sunucu ismi ve şemayı sunucu
      ekler.</p>

    <p><code><em>URL-yolu</em></code> ile başlayan istekler istemciye hedef
      <code><em>URL</em></code> konumuna bir yönlendirme isteği olarak
      dönecektir. <code><em>URL-yolu</em></code>’nun devamı niteliğindeki ek
      yol hedef URL’ye eklenir.</p>

    <example><title>Örnek:</title>
      Redirect /hizmet http://iki.mesela.dom/hizmet
    </example>

    <p>İstemcinin yaptığı <code>http://mesela.dom/hizmet/fesmekan.txt</code>
      isteğine karşılık istemciye isteği
      <code>http://iki.mesela.dom/hizmet/fesmekan.txt</code> olarak yapması
      söylenecektir. Sadece tam yol parçaları eşleştirilir, bu nedenle
      <code>http://mesela.dom/hizmetfesmekan.txt</code> isteği yukarıdaki
      yönlendirme ile eşleşmeyecektir. Düzenli ifadelerin kullanıldığı daha
      karmaşık eşleşmeler için <directive module="mod_alias"
      >RedirectMatch</directive> yönergesine bakınız.</p>


    <note><title>Bilginize</title>
      <p>Yapılandırma dosyasında yer alış sırasına bakmaksızın
        <directive>Redirect</directive> yönergeleri
        <directive>Alias</directive> ve <directive>ScriptAlias</directive>
        yönergelerinden önce ele alınır.</p></note>

      <p>Herhangi bir <code><em>durum</em></code> belirtilmemişse "geçici"
        yönlendirme (HTTP durum kodu: 302) yapılır. Bu, istemciye özkaynağın
        geçici olarak başka yere taşındığını belirtir. Diğer HTTP durum
        kodlarını döndürmek için kullanılabilecek <code><em>durum</em></code>
        değerleri:</p>

    <dl>
      <dt><code>permanent</code></dt>
      <dd>İstemciye özkaynağın kalıcı olarak taşındığını belirten kalıcı
        yönlendirme durumu (301) döndürülür.</dd>

      <dt><code>temp</code></dt>
      <dd>İstemciye geçici yönlendirme durumu (302) döner. Bu öntanımlıdır.
      </dd>

      <dt><code>seeother</code></dt>
      <dd>İstemciye özkaynağın yerine başka bir şey konduğunu belirten
        "diğerine bak" durumu (303) döndürülür.</dd>

      <dt><code>gone</code></dt>
      <dd>İstemciye özkaynağın kalıcı olarak kaldırıldığını belirten "ölü
        bağlantı" durumu (410) döner. Bu durumda <code><em>URL</em></code>
        belirtilmez.</dd>
    </dl>

    <p>Diğer durum kodları için <code><em>durum</em></code> olarak sayısal
      durum kodu belirtilir. Eğer durum 300 ile 399 arasındaysa bir
      <code><em>URL</em></code> belirtmek gereklidir, yoksa belirtilmez.
      Belirtilecek durum kodunu Apache’nin bilmesi gerektiğine dikkat ediniz
      (<code>http_protocol.c</code> dosyasında bulunan
      <code>send_error_response</code> işlevine bakınız).</p>

    <example><title>Örnek:</title>
      Redirect permanent /bir http://mesela.dom/iki<br />
      Redirect 303 /yedi http://mesela.dom/baskabisey
    </example>
  </usage>
</directivesynopsis>

<directivesynopsis>
<name>RedirectMatch</name>
<description>Geçerli URL ile eşleşen bir düzenli ifadeye dayanarak bir harici
yönlendirme gönderir.</description>
<syntax>RedirectMatch [<var>durum</var>] <var>düzenli-ifade</var>
<var>URL</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>FileInfo</override>

  <usage>
    <p>Bu yönerge <code><em>URL-yolu</em></code> ile eşleşmek üzere bir
      <glossary ref="regex">düzenli ifade</glossary> kabul etmesi dışında
      <directive module="mod_alias">Redirect</directive> yönergesine
      eşdeğerdir. Belirtilen düzenli ifade <code><em>URL-yolu</em></code> ile
      eşleşiyorsa sunucu parantezli eşleşmeleri belirtilen dizgede kullanarak
      dosya yolunu elde eder. Örneğin, tüm GIF dosyası isteklerini başka bir
      sunucudaki aynı isimli JPEG dosyalarına yönlendirmek için şu
      yazılabilir:</p>

    <example>
      RedirectMatch (.*)\.gif$ http://baska.sunucu.dom$1.jpg
    </example>
  </usage>
</directivesynopsis>

<directivesynopsis>
<name>RedirectTemp</name>
<description>İstemciyi, geçici bir yönlendirme isteği döndürerek farklı bir
URL’ye yönlendirir.</description>
<syntax>RedirectTemp <var>URL-yolu</var> <var>URL</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>FileInfo</override>

  <usage>
    <p>Bu yönerge istemciye daima geçici yönlendirme durumu (302) döndürür.
      Yani, <code>Redirect temp</code> ile aynı işi yapar.</p>
  </usage>
</directivesynopsis>

<directivesynopsis>
<name>RedirectPermanent</name>
<description>İstemciyi, kalıcı bir yönlendirme isteği döndürerek farklı bir
URL’ye yönlendirir.</description>
<syntax>RedirectPermanent <var>URL-yolu</var> <var>URL</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>FileInfo</override>

  <usage>
    <p>Bu yönerge istemciye daima kalıcı yönlendirme durumu (301) döndürür.
      Yani, <code>Redirect permanent</code> ile aynı işi yapar.</p>
  </usage>
</directivesynopsis>

<directivesynopsis>
<name>ScriptAlias</name>
<description>Bir URL’yi dosya sistemindeki bir yere eşler ve hedefi bir CGI betiği olarak çalıştırır.</description>
<syntax>ScriptAlias <var>URL-yolu</var>
<var>dosya-yolu</var>|<var>dizin-yolu</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

  <usage>
    <p>Hedef dizini, <module>mod_cgi</module> modülünün CGI betiği
      yorumlayıcısı tarafından çalıştırılacak betikleri içeren dizin olarak
      imlemesi dışında <directive module="mod_alias">Alias</directive>
      yönergesinin yaptığı işi yapar. <code><em>URL-yolu</em></code> ile
      başlayan harf büyüklüğüne duyarlı URL’ler (% imlemesi çözüldükten
      sonra), dosya sistemindeki bir tam yol olarak belirtilmiş
      <code><em>dizin-yolu</em></code> ile başlayan betiklerle eşlenir.</p>

    <example><title>Örnek:</title>
      ScriptAlias /cgi-bin/ /siteler/cgi-bin/
    </example>

    <p><code>http://mesela.dom/cgi-bin/foo</code> şeklindeki bir istek sunucunun
      <code>/siteler/cgi-bin/foo</code> betiğini çalıştırmasına sebep olur. Bu
      yapılandırma aslında şuna eşdeğerdir:</p>

    <example>
      Alias /cgi-bin/ /siteler/cgi-bin/<br />
      &lt;Location /cgi-bin &gt;<br />
      <indent>
      SetHandler cgi-script<br />
      Options +ExecCGI<br />
      </indent>
      &lt;/Location&gt;
    </example>

    <note type="warning">Yapılandırma değiştiğinde kaynak kodlarının ister
      istemez açığa çıkmasını istemiyorsanız CGI betiklerinizi <directive
      module="core">DocumentRoot</directive> altına koymayınız.
      <directive>ScriptAlias</directive> yönergesi URL’yi doğru yere
      eşlemekten başka orayı bir CGI betikleri dizini olarak imler. CGI
      betiklerinizi <directive module="core">DocumentRoot</directive> altına
      koyarsanız çalıştırmak için <directive>ScriptAlias</directive> değil,
      <directive module="core" type="section" >Directory</directive>,
      <directive module="core">SetHandler</directive> ve <directive
      module="core">Options</directive> yönergelerini örnekteki gibi kullanın:

    <example>
      &lt;Directory /usr/local/apache2/htdocs/cgi-bin &gt;<br />
      <indent>
      SetHandler cgi-script<br />
      Options ExecCGI<br />
      </indent>
      &lt;/Directory&gt;
    </example>

     Aynı dosya sistemi konumu ile çok sayıda <code><em>URL-yolu</em></code>
     eşleşebileceğinden, bir <directive module="core">Directory</directive>
     bölümü ile sınırlanmadığı takdirde CGI betiklerinin kaynak kodları açığa
     çıkabilir; bu bakımdan <directive>ScriptAlias</directive> yönergesini yok
     sayan URL yollarının belirtilebilme olasılığı gözardı
     edilmemelidir.</note>

  </usage>
  <seealso><a href="../howto/cgi.html">CGI Öğreticisi</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ScriptAliasMatch</name>
<description>Bir URL’yi dosya sistemindeki bir yere düzenli ifade kullanarak
eşler ve hedefi bir CGI betiği olarak çalıştırır.</description>
<syntax>ScriptAliasMatch <var>düzenli-ifade</var>
<var>dosya-yolu</var>|<var>dizin-yolu</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

  <usage>
    <p>Bu yönerge <code><em>URL-yolu</em></code> ile eşleşmek üzere bir
      <glossary ref="regex">düzenli ifade</glossary> kabul etmesi dışında
      <directive module="mod_alias">ScriptAlias</directive> yönergesine
      eşdeğerdir. Belirtilen düzenli ifade <code><em>URL-yolu</em></code> ile
      eşleşiyorsa sunucu parantezli eşleşmeleri belirtilen dizgede kullanarak
      dosya yolunu elde eder. Örneğin, standart <code>/cgi-bin</code> dizinini
      etkin kılmak için şu yazılabilir:</p>

    <example>
      ScriptAliasMatch ^/cgi-bin(.*) /usr/local/apache/cgi-bin$1
    </example>

    <p>AliasMatch'teki gibi, burada da <glossary ref="rexex">düzenli
      ifadeler</glossary> tüm gücüyle kullanılabilir. Örneğin, bir URL yolu ile
      harf büyüklüğüne duyarsız eşleşme sağlayan bir rumuz oluşturmak
      mümkündür:</p>

    <example>
      ScriptAliasMatch (?i)^/cgi-bin(.*) /usr/local/apache/cgi-bin$1
    </example>

    <p><directive module="mod_alias">Alias</directive> ve
      <directive module="mod_alias">AliasMatch</directive> arasındaki farklarla
      ilgili herşey burada da geçerlidir. Ayrıntılar için  <directive
      module="mod_alias">AliasMatch</directive>yönergesine bakınız.</p>
</usage>
</directivesynopsis>

</modulesynopsis>

