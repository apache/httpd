<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">

<!-- mod_fastcgi.html                                                     -->
<!--	Documentation for the mod_fastcgi Apache module                   -->
<!-- Copyright (c) 1996 Open Market, Inc.                                 -->
<!-- See the file "LICENSE.TERMS" for information on usage and            -->
<!-- redistribution of this file, and for a DISCLAIMER OF ALL WARRANTIES. -->

<html>
<head>
<title>Apache module mod_fastcgi</title>
</head>

<body>
<IMG SRC="http://www.apache.org/images/apache_sub.gif" ALT="">
<!--/%hypertext -->



<h1>Module mod_fastcgi</h1>

This module is contained in the <code>mod_fastcgi.c</code> file, and
is not compiled into the server by default.
To use <code>mod_fastcgi</code> you first copy
<code>src/mod_fastcgi.c</code> from this kit into your Apache server's
source directory. Then you add the following line to the server build
Configuration file:
<pre>
        Module fastcgi_module    mod_fastcgi.o
</pre>
<p>
FastCGI provides a high-performance alternative to CGI for writing Web
server applications in a variety of languages, including Perl, C, C++,
Java, and Python.  FastCGI gets its speed by having keeping
application processes running between requests. So, unlike CGI, you do
not have the overhead of starting up a new process and doing
application initialization (e.g. connecting to a database) each time
somebody requests a document.<p>

FastCGI applications communicate with a Web server using a simple
communications protocol.  A single full-duplex connection communicates
the environment variables and <code>stdin</code> data to the
application, and <code>stdout</code> and <code>stderr</code> data to
the Web server.  An application can reside on a different
machine from the Web server, allowing applications to scale beyond
a single box and providing easier integration with existing systems.<p>

For more information on FastCGI, including freely available FastCGI
server modules and application libraries, go to the <A
HREF="http://www.fastcgi.com/">FastCGI website
(http://www.fastcgi.com/)</A>.<p>



<h2>Summary</h2>

In order to configure FastCGI applications, you need a combination of
<code>mod_fastcgi</code> directives and other directives provided by
the Apache server.<p>

You use the
<code>AppClass</code> directive to start the FastCGI 
applications that you want to be managed by this Web server.  The
applications are managed in the sense that the server (a) logs an
error message when a managed process dies and (b) attempts to
restart managed processes that die.<p>

You use one or both of the
<code>AppClass</code> and <code>ExternalAppClass</code> directives
to define an association between a pathname and the connection 
information for a FastCGI application.  Connection
information is either the pathname of
a Unix domain socket or the IP address and port number of a
TCP port.  The difference between the two directives
is that a single <code>AppClass</code> 
directive both starts an application and sets up the association
for communicating with it, while <code>ExternalAppClass</code> only
defines the association.  In the case of <code>AppClass</code>,
the pathname used in the association is always the pathname of the
application's executable; with <code>ExternalAppClass</code> the pathname
is arbitrary.<p>

In order for an HTTP request to be processed by <code>mod_fastcgi</code>
the request's handler must be <code>fastcgi-handler</code>
or the request's MIME type must be
<code>application/x-httpd-fcgi</code>.  Apache
provides several ways to set the handler and MIME type of
a request:

<ul>
  <li> <code>SetHandler</code> (in the context of a <code>Location</code>
         or <code>Directory</code> section or <code>.htaccess</code>
         file) can associate the handler
         <code>fastcgi-handler</code> with
         a specific file, or all the files in a directory.<p>
  <li> <code>AddHandler</code> can associate the handler
         <code>fastcgi-handler</code> with
         files based on file extension.<p>
  <li> <code>ForceType</code> (in the context of a <code>Location</code>
         or <code>Directory</code> section or <code>.htaccess</code>
         file) can associate the MIME type
         <code>application/x-httpd-fcgi</code> with
         a specific file, or all the files in a directory.<p>
  <li> <code>AddType</code> can associate the MIME type
         <code>application/x-httpd-fcgi</code> with
         files based on file extension.<p>
</ul>

Refer to the documentation for <code>mod_mime</code>
for more information on these directives, and to the documentation
of the Apache core features for information on <code>Location</code>
and <code>Directory</code> sections.<p>

<code>mod_fastcgi</code> handles requests as follows:

<ul>
  <li> <code>mod_fastcgi</code> retrieves the connection
        information associated with the requested pathname.
  <li> if no connection information is associated with the pathname, 
	the server returns <code>404 Not Found</code>.
  <li> <code>mod_fastcgi</code> connects to the FastCGI application process.
  <li> if the connection attempt fails, 
	the server returns <code>500 Server Error</code>.
  <li> <code>mod_fastcgi</code> transmits the request to the
        FastCGI application process, which generates a response.
  <li> <code>mod_fastcgi</code> receives the application's
        response and transforms
        it into an HTTP response.  The server sends
        this response back to the client.
</ul>

The configuration examples below show some valid ways to configure
<code>mod_fastcgi</code>.


<h2>Directives</h2>

<ul>
  <li>
    <a HREF="#AppClass">AppClass</a>
  <li>
    <a HREF="#ExternalAppClass">ExternalAppClass</a>
  <li>
    <a HREF="#FastCgiIpcDir">FastCgiIpcDir</a>
</ul>
<hr>


<A name="AppClass"><h2>AppClass</h2></A>
<strong>Syntax:</strong> AppClass path-name
                   <em>[-processes N] [-listen-queue-depth N] 
	           [-restart-delay N] [-priority N] 
	 	   [-port N] [-socket sock-name]
                   [-initial-env name=value]<br></em>
<strong>Context:</strong> srm.conf<br>
<strong>Module:</strong> mod_fastcgi<p>

The <code>AppClass</code> directive starts one or more FastCGI
application processes, using the executable file
<code>path-name</code>.  Should any of these processes die, 
<code>mod_fastcgi</code> will write an error log entry and restart
the faulty process.<p>

The optional parameters to the <code>AppClass</code> directive
are as follows:
<ul>
  <li>
    <B>processes:</B> number of FastCGI processes that the Web server
    will spawn, default 1.<p>

  <li>
    <B>listen-queue-depth:</B> depth of listen queue
    shared by the processes, default 5.  A deeper listen queue
    allows the server to cope with transient
    load fluctuations without rejecting
    requests; it does not increase throughput.  Adding extra processes
    may increase throughput, depending upon the application and the
    host.<p>

  <li>
    <B>restart-delay:</B> number of seconds between restarts of
    processes in this class, default 5.  When the first process dies
    it will be restarted immediately, but if a second process from
    this class dies within <code>restart-delay</code> seconds, it will
    not be restarted until <code>restart-delay</code> seconds have
    passed since the previous restart.  This delay prevents a broken
    application from soaking up too much of the system.  Default value
    is 5 seconds.<p>

  <li>
    <B>priority:</B> priority of FastCGI application processes, as
    defined by the <code>setpriority</code> system call.  The default
    value is zero, i.e. same priority as the HTTP server.  Negative
    values are not allowed.<p>

  <li>
    <B>port:</B> TCP port number that the FastCGI application
    process will listen on.  Using this
    option makes the application accessible from the another
    machine (as well as from this one.)  An argument to the
    <code>port</code> option should be a number 
    between 1 and 65535.<p>

  <li>
    <B>socket:</B> pathname of the Unix domain socket that
    the FastCGI application process will listen on.  The
    module creates this socket within the directory
    specified by <code>FastCgiIpcDir</code>.  Using this option
    makes the application accessible to other Web servers or
    applications (e.g. <code>cgi-fcgi</code>) on the same machine
    or via multiple pathnames on this Web server
    (using <code>ExternalAppClass</code>.)
    If neither the <code>-socket</code> nor the <code>-port</code>
    options are given, the Web server generates a Unix domain
    socket name itself.<p>

  <li>
    <B>initial-env:</B> a name-value pair in the initial environment
    passed to the application processes.  The argument has the form
    <code>name=value</code>, with no whitespace allowed.
    You can add several name-value pairs to the initial environment
    by using this option several times.  The default
    initial environment is empty (no name-value pairs.)<p>
</ul>
<p>
The <code>-socket</code> and <code>-port</code> options are 
mutually exclusive.
<code>path-name</code>
must not equal the <code>path-name</code> supplied to an
earlier <code>AppClass</code> or <code>ExternalAppClass</code>
directive.  Other errors
possible in the <code>AppClass</code>
directive include syntax errors, arguments out of range, and the file
<code>path-name</code> being non-existent or not executable.
<p>


<A name="ExternalAppClass"><h2>ExternalAppClass</h2></A>
<strong>Syntax:</strong> ExternalAppClass path-name
                   <em>[-host host:port] 
	           [-socket sock-name]<br></em>
<strong>Context:</strong> srm.conf<br>
<strong>Module:</strong> mod_fastcgi<p>

The <code>ExternalAppClass</code> directive provides a connection a
FastCGI application process that is listening to a specified TCP port 
or a UNIX domain socket.  <code>ExternalAppClass</code> is most commonly
used to communicate with a FastCGI application running on a different 
machine.  This directive implies nothing about how the FastCGI application
is managed (started, restarted, etc.).  <code>path-name</code>
simply provides an identifier for the connection.<p>

The optional parameters to the <code>ExternalAppClass</code> directive
are as follows:
<ul>
  <li>
    <B>host:</B> the host and port of the machine on which a FastCGI 
    process is running.  The argument should be a single string, 
    containing the host IP address (either as
    a hostname to be resolved via DNS or as a "dotted quad"
    such as "123.96.248.182"), followed by a colon (":"),
    followed by a port number
    (an integer between 1 and 65535.)<p>

  <li>
    <B>socket:</B> full pathname of a Unix Domain socket accessible
    from this Web server.  Most commonly, the FastCGI 
    application listening on this socket would have been started by an
    <code>AppClass</code> directive with the <code>-socket</code>
    option.<p>
</ul>
<p>
Exactly one of the <code>port</code> and <code>socket</code>
parameters must be supplied.  <code>path-name</code>
must not equal the <code>path-name</code> supplied to an
earlier <code>AppClass</code> or <code>ExternalAppClass</code>
directive.  Other
errors possible in the <code>ExternalAppClass</code>
directive include syntax errors and arguments out of range.
<p>


<A name="FastCgiIpcDir"><h2>FastCgiIpcDir</h2></A>
<strong>Syntax:</strong> FastCgiIpcDir dir-path<br>
<strong>Context:</strong> srm.conf<br>
<strong>Module:</strong> mod_fastcgi<p>

The <code>FastCgiIpcDir</code> directive controls where
<code>mod_fastcgi</code> creates Unix-domain sockets
for communicating with the applications it manages.<p>

By default, <code>mod_fastcgi</code> creates
the sockets in <code>/tmp</code>.  The socket
names have the form <code>OM_WS_n.pid</code> where <code>n</code> is a
sequence number and <code>pid</code> is the process ID of the Apache
parent process.  If your system runs a periodic job to delete files
from <code>/tmp</code>, and it deletes these files, your Web
server won't be able to communicate with its FastCGI applications.<p>

To avoid this problem place a <code>FastCgiIpcDir</code> directive
before the <code>AppClass</code> directives in your server
configuration.  Specify a directory that's readable, writeable,
and searchable by the account you use for your Web server, but
otherwise not accessible to anyone.<p>

Note 1 below describes platform-specific problems
in moving the sockets out of <code>/tmp</code>; please read it.<p>


<hr>

<h2>Important notes</h2>

<ol>

  <li>
    On some platforms, Unix-domain sockets don't work when stored
    in non-local file systems.  Digital UNIX 3.0 is known to have
    this problem with NFS (fixed in Digital UNIX 3.2);
    Solaris 2.5 is known to have this problem
    with AFS.  If <code>/tmp</code> is part of a local
    file system you'll avoid this problem by leaving the
    listening sockets in <code>/tmp</code> rather than using the
    <code>FastCgiIpcDir</code> directive to put them somewhere else.<p>

  <li>
    Error logging by the <code>mod_fastcgi</code> process manager
    corrupts the error log on some platforms, due to a bug in the C
    library function <code>fopen</code>.  For instance, SunOS 4.1.4
    has the <code>fopen</code> bug and exhibits the error log
    corruption problem.  A corrupted error log makes it difficult to
    debug problems on your Web server.  You should apply the following
    patch to Apache 1.1.1 in order to eliminate the possibility of
    this problem: (Note: This patch is reversed and must be applied
    with a <em>-R</em> flag to <em>patch</em>)
    <pre>
% diff -c alloc.c alloc.c.orig
*** alloc.c     Mon Sep 23 17:45:34 1996
--- alloc.c.orig        Mon Sep 23 17:43:16 1996
***************
*** 765,784 ****
  
  FILE *pfopen(struct pool *a, char *name, char *mode)
  {
!   FILE *fd = NULL;
  
    block_alarms();
!   if (*mode == 'a') {
!     /* Work around faulty implementations of fopen */
!     int baseFlag = (*(mode+1) == '+') ? O_RDWR : O_WRONLY;
!     int desc = open(name, baseFlag | O_APPEND | O_CREAT,
!             S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
!     if (desc &gt;= 0) {
!       fd = fdopen(desc, mode);
!     }
!   } else {
!     fd = fopen(name, mode);
!   }
    if (fd != NULL) note_cleanups_for_file (a, fd);
    unblock_alarms();
    return fd;
--- 765,774 ----
  
  FILE *pfopen(struct pool *a, char *name, char *mode)
  {
!   FILE *fd;
  
    block_alarms();
!   fd = fopen(name, mode);
    if (fd != NULL) note_cleanups_for_file (a, fd);
    unblock_alarms();
    return fd;
    </pre>

  <li>
    The <code>ScriptAlias</code> directive takes priority over the
    <code>AddType</code> directive: A file located in a directory that
    is the target of <code>ScriptAlias</code> is always
    handled by the handler <code>cgi-handler</code> (<code>mod_cgi</code>.)
    So don't put FastCGI applications in a <code>ScriptAlias</code>
    directory -- the applications won't work properly!<p>

  <li>
    The optional module <code>mod_env</code> provides two directives
    (<code>PassEnv</code> and <code>SetEnv</code>) that are designed
    for passing environment variables to CGI scripts.  These
    directives also work for passing per-request environment variables
    to FastCGI applications.  To pass initial environment variables
    you must use the <code>-initial-env</code> option to
    <code>AppClass</code>.<p>

  <li>
    <code>mod_fastcgi</code> does not implement the Authorizer or Filter
    roles described in the FastCGI specification.  However, you can
    approximate the Filter role using Apache's <code>Action</code>
    directive to route requests to a FastCGI Responder.
    See the documentation for <code>mod_actions</code> for information
    on the <code>Action</code> directive.<p>

  <li>
    See the <a href="README"><code>README</code></a> file for a complete
    list of known bugs in this version of <code>mod_fastcgi</code>.<p>

</ul>


<h2>Notes on CGI response headers</h2>

You may have noticed that <code>mod_fastcgi</code> makes no
provision for non-parsed-header scripts.  There's a good reason for
this: <code>mod_fastcgi</code> does not restrict the functionality
of parsed-header scripts in any way.  A parsed-header script
can do anything that an "nph" script can do, and some things
that an "nph" script can't do.<p>

To exploit the power of parsed-header scripts you need
to understand the three standard CGI/1.1
response headers:<p>

<ul>
  <li><code>Status:</code> an HTTP status line, e.g.
      <code>"206 Partial Content"</code>.<p>
  <li><code>Location:</code> a URL or absolute path to content.<p>
  <li><code>Content-type:</code> the media type of script-generated
      response content.<p>
</ul>

Only certain combinations of these headers make sense:<p>

<ul>
  <li>Each header may appear at most once in a response.<p>
  <li>The <code>Status</code> and <code>Location</code> headers
      are mutually exclusive, i.e. at most one may appear
      in a response.  If neither appears, the effect
      is as if <code>Status: 200 OK</code> appeared, and
      a <code>Content-type</code> header must appear.<p>
  <li>A <code>Content-type</code> header means that
      the script will generate response content (e.g.
      an HTML document), and the
      absence of a <code>Content-type</code> header means
      that the script will not generate response content.<p>
  <li>A <code>Location</code> header may only be generated
      in response to a <code>GET</code> or <code>HEAD</code>
      request.<p>
</ul>

The <code>Location</code> header specifies a redirect.
There are two kinds.  If the <code>Location</code> value
is a full URL (e.g. <code>http://www.fastcgi.com/servers/apache</code>),
the effect is to generate an HTTP 302 response.  If the
<code>Location</code> value is an absolute path
(e.g. <code>/servers/apache</code>), the effect is to
execute a recursive request for that path within the server,
and return the response of that request.<p>

<code>Location</code> is optionally accompanied by
<code>Content-type</code>.  If the <code>Location</code> value
is a full URL and no <code>Content-type</code> is specified,
the Web server provides standardized content (of type
<code>text/html</code>); if a <code>Content-type</code> is specified,
the script provides the content.  If the <code>Location</code> value
is an absolute path then script-generated <code>Content-type</code> and
content are ignored.<p>

<code>mod_fastcgi</code> performs buffering of script-provided
content, but content is not allowed to linger in buffers
for more than a fraction of a second.  Therefore "server push"
scripts work correctly.<p>


<h2>Configuration example</h2>

What follows is a minimal httpd.conf for Apache 1.1.1 and FastCGI
Developer's Kit 1.5.  Use this configuration for initial testing
with FastCGI.  When you've verified that this configuration works,
you can merge the FastCGI-specific aspects of this configuration
with your own configuration.<p>

Directions:

<ol>
  <li>
    Change <code>$APACHE</code> to the path name of the directory
    containing your Apache 1.1.1 kit, i.e. the directory containing
    the Apache 1.1.1 README.  For instance, you might change
    <code>$APACHE</code> to <code>/udir/doe/apache_1.1.1</code>.<p>

    Change <code>$FASTCGI</code> to the path name of the directory
    containing your FastCGI Developer's Kit 1.5, i.e. the directory
    containing the FastCGI Developer's Kit 1.5 README.  For instance,
    you might change <code>$FASTCGI</code> to
    <code>/udir/doe/fcgi-devel-kit</code>.<p>

    Save the resulting file as <code>$APACHE/conf/httpd.conf</code>.<p>

  <li>
    Build Apache 1.1.1 with <code>mod_fastcgi</code>.  This creates the
    <code>httpd</code> executable.<p>
 
    Build the FastCGI Developer's Kit 1.5.  This creates the
    <code>echo</code> executable that you are going to run as a
    FastCGI application.<p>

  <li>
    In a shell, cd to <code>$APACHE</code> and start httpd:
    <pre>
    % src/httpd -f $APACHE/conf/httpd.conf
    </pre><p>

  <li>
    Use a browser to access the URL
    <pre>
    http://$YOUR_HOST:5556/examples/echo
    </pre>
    where <code>$YOUR_HOST</code> is the IP address of the host
    running httpd.  Look for <code>STATE=TEXAS</code> in the
    initial environment that <code>echo</code> displays.  The
    request counter should increment each time you reload the page.<p>
</ol>

<pre>
# httpd.conf -- minimal for mod_fastcgi
#
# One config file is plenty
ResourceConfig /dev/null
AccessConfig   /dev/null

# Not starting httpd as root, so Port must be larger than 1023
Port 5556

# This is what you'd add to the config if the server is to be
# started as root.  Don't do this until you've verified that the
# server works when started as non-root!  Don't use user/group nobody;
# define a new user and group specifically for running the server.
# User httpd
# Group httpd

# Configure just one idle httpd child process, to simplify debugging
StartServers    1
MinSpareServers 1
MaxSpareServers 1

# Tell httpd where it should live, turn on access and error logging
ServerRoot     $APACHE
ErrorLog       logs/error.log
TransferLog    logs/access.log
ScoreBoardFile logs/httpd.scoreboard

# Tell httpd where to get documents
DocumentRoot $FASTCGI

# This is how you'd place the Unix-domain socket files in the logs
# directory (you'd probably want to create a subdirectory for them.)
# Don't do this until you've verified that everything works with
# the socket files stored locally, in /tmp!
# FastCgiIpcDir $APACHE/logs

# Start the echo app
AppClass $FASTCGI/examples/echo -initial-env STATE=TEXAS

# Have mod_fastcgi handle requests for the echo app
# (otherwise the server will return the app's binary as a file!)
&lt;Location /examples/echo&gt;
SetHandler fastcgi-script
&lt;/Location&gt;

# Start a FastCGI application that's accessible from other machines
AppClass $FastCGI/examples/echo.fcg -port 8978
&lt;Location /examples/echo.fcg&gt;
SetHandler fastcgi-script
&lt/Location&gt;

# Connect to "remote" app started above.  Since the app is actually
# local, communication will take place using TCP loopback.
# To test true remote operation, start one copy of this
# Web server on one machine, then start another copy with
# "localhost" in the line below changed to the host name of the first machine.
ExternalAppClass $FASTCGI/examples/remote-echo -host localhost:8978
&lt;Location /examples/remote-echo&gt;
SetHandler fastcgi-script
&lt/Location&gt;

# This is how you'd have mod_fastcgi handle any request for a file
# whose name ends in .fcg:
# AddHandler fastcgi-script fcg

# End of httpd.conf
</pre>

<!--#include virtual="footer.html" -->
</BODY>
</HTML>
