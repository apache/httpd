<HTML>
<HEAD>
<TITLE>eXtended Server Side Includes (XSSI)</TITLE>
</HEAD>

<BODY>

<H1 ALIGN=CENTER>eXtended Server Side Includes (XSSI)</H1>
<CENTER><P ALIGN=CENTER>
    [<A HREF="#lang">Language</A>]
    [<A HREF="#install">Installation</A>]
    [<A HREF="#notes">Notes</A>]
</P></CENTER>

<P> The eXtended Server Side Include 
    (<A HREF="ftp://pageplus.com/pub/hsf/xssi/">XSSI</A>)
    extension to the
    <A HREF="http://www.apache.org/">Apache HTTP Server</A>
    allows web developers to create dynamic documents without 
    having to write CGI scripts.
    Some of the capabilities that I wanted include:</P>

<UL>
<LI>Ability to change the document's html based on the web browser.
<LI>Ability to maintain common headers and footers that contain
    some document specific information.
<LI>Ability to maintain copies of a web on multiple servers.
</UL>
<P> While this could all be done with CGI scripts, this suffers
    several problems:
<UL>
<LI>Many web developers don't have access to CGI due to ISP restrictions.
<LI>Embedding content inside a CGI program makes content maintenance
    more difficult.
<LI>CGI scripts often depend on having multiple copies of the same
    information (for different browsers for example) which also makes
    content maintenance much more difficult.
<LI>Many web developers don't have programming expertise with Perl, tcl,
    c, or other CGI languages.
</UL>

<P> XSSI is designed for the casual web developer.  Someone developing a
    departmental or personal home page on a intranet for example.  It is
    not intended to be a replacement for CGI.  It is intended to simplify
    casual web page development and maintenance.

<P> XSSI is a drop-in replacement for the standard
    <A HREF="http://hoohoo.ncsa.uiuc.edu/docs/tutorials/includes.html"><!--
    -->Server Side Include</A> feature of Apache.
    It works by pre-processing the target file and sending the resulting
    HTML document to the output stream.  This is transmitted back to
    the browser by the httpd server.

<P> This guide covers
    the complete XSSI language including both the original and the
    new directives.</P>

<HR>
<H2><A NAME="lang">The XSSI Language</A></H2>

<P> Extended server side include directives are implemented as
    as SGML comments in case the document should ever be handled
    without being parsed.  Each directive has the following format:</P>

<PRE>
    &lt;!--#command tag1="value1" tag2="value2" --&gt;
</PRE>

<P> <H3>Variables</H3></P>

<P> XSSI supports variables.  You can use variables in the
    tag value (for all tags except <I>var=</I>) of all directives: 
<PRE>
    &lt;!--#command tag1="$variable" --&gt;
    &lt;!--#command tag1="text${variable}more text" --&gt;
</PRE>

<P> The <B><CODE>set</CODE></B> directive is used to set the value of a
    variable:
<PRE>
    &lt;!--#set var="<I>variable_name</I>" value="<I>variable_value</I>"--&gt;
</PRE>

<P> Some variables are set for the user.  In addition to the
    <A HREF="http://hoohoo.ncsa.uiuc.edu/cgi/env.html">CGI variable set</A>,
   the following variables are made available:
<UL>
<LI><P><CODE>DOCUMENT_NAME</CODE>: The current filename.</P>
<LI><P><CODE>DOCUMENT_URI</CODE>: The virtual path to this document
    (such as /docs/tutorials/foo.shtml).</P>
<LI><P><CODE>QUERY_STRING_UNESCAPED</CODE>: The unescaped version of any
    search query the client sent, with all shell-special characters
    escaped with \.</P>
<LI><P><CODE>DATE_LOCAL</CODE>: The current date, local time zone.
    Subject to the <CODE>timefmt</CODE> parameter to the
    <CODE>config</CODE> command.</P>
<LI><P><CODE>DATE_GMT</CODE>: Same as DATE_LOCAL but in Greenwich mean
    time.</P>
<LI><P><CODE>LAST_MODIFIED</CODE>: The last modification date of the
    current document. Subject to <CODE>timefmt</CODE> like the others.</P>
</UL>

<P> The format of date and file size variables are set using the
    <B><CODE>config</CODE></B> directive:
<PRE>
    &lt;!--#config errmsg="<I>your error message</I>" --&gt;
    &lt;!--#config timefmt="<I>strftime_time_format</I>" --&gt;
    &lt;!--#config sizefmt="<I>bytes | abbrev</I>" --&gt;
</PRE>

<UL>
<LI><P><CODE>errmsg</CODE> controls what message is sent back to the
    client if an error includes while parsing the document. When an error
    occurs, it is logged in the server's error log.</P>

<LI><P><CODE>timefmt</CODE> gives the server a new format to use when
    providing dates. This is a string compatible with the
    <CODE>strftime</CODE> library call under most versions of UNIX.</P>

<LI><P><CODE>sizefmt</CODE> determines the formatting to be used when
    displaying the size of a file. Valid choices are <CODE>bytes</CODE>,
    for a formatted byte count (formatted as 1,234,567), or
    <CODE>abbrev</CODE> for an abbreviated version displaying the number
    of kilobytes or megabytes the file occupies.</P>
</UL>

<P> <H3>Output Directives</H3></P>

<P> The <B><CODE>echo</CODE></B> directive prints the value a variable to the
    output stream.
<PRE>
    &lt;!--#echo var="<I>variable_name</I>" --&gt;
</PRE>

<P> The <B><CODE>printenv</CODE></B> directive prints all variables currently
    set:
<PRE>
    &lt;!--#printenv --&gt;
</PRE>
<P> The output is a series of lines: variable=value.  For debugging
    purposes, you probably want to enclose this directing in a
    &lt;PRE&gt; container.

<P> The <B><CODE>fsize</CODE></B> directive prints the size of the specified file.
    The resulting format of this command is subject to the
    <CODE>sizefmt</CODE> parameter to the <CODE>config</CODE> command.</P>
<PRE>
    &lt;!--#fsize virtual="<I>URL</I>" --&gt;
    &lt;!--#fsize file="<I>path</I>" --&gt;
</PRE>
<UL>
<LI><P><CODE>virtual</CODE> gives a URL reference (which may be relative)
    to a document on the server. You must access a normal file this way,
    you cannot access a CGI script in this fashion. You can, however,
    access another parsed document. </P>

<LI><P><CODE>file</CODE> gives a pathname relative to the current
    directory. ../ cannot be used in this pathname, nor can absolute paths
    be used. As above, you can send other parsed documents, but you cannot
    send CGI scripts. </P>
</UL>

<P> The <B><CODE>flastmod</CODE></B> directive prints the last
    modification date of the
    specified file, subject to the formatting preference given by the
    <CODE>timefmt</CODE> parameter to <CODE>config</CODE>.</P>
<PRE>
    &lt;!--#flastmod virtual="<I>URL</I>" --&gt;
    &lt;!--#flastmod file="<I>path</I>" --&gt;
</PRE>
<UL>
<LI><P><CODE>virtual</CODE> gives a URL reference (which may be relative)
    to a document on the server. You must access a normal file this way,
    you cannot access a CGI script in this fashion. You can, however,
    access another parsed document. </P>

<LI><P><CODE>file</CODE> gives a pathname relative to the current
    directory. ../ cannot be used in this pathname, nor can absolute paths
    be used. As above, you can send other parsed documents, but you cannot
    send CGI scripts. </P>
</UL>


<P> <H3>Flow Control Directives</H3></P>
<P> The basic flow control directives in XSSI are:
<PRE>
    &lt;!--#if expr="<I>test_condition</I>" --&gt;
    &lt;!--#elif expr="<I>test_condition</I>" --&gt;
    &lt;!--#else --&gt;
    &lt;!--#endif --&gt;
</PRE>
<P> The <B><CODE>if</CODE></B> directive works like an
    if statement in a programming language.  The test condition
    is evaluated and if the result is true, then the text until
    the next <B><CODE>elif</CODE></B>, <B><CODE>else</CODE></B>.
    or <B><CODE>endif</CODE></B> directive is included in the
    output stream.

<P> The <B><CODE>elif</CODE></B> or <B><CODE>else</CODE></B>
    statements are be used the put text into the output stream
    if the original test_condition was false.  These directives
    are optional.

<P> The <B><CODE>endif</CODE></B> statement ends the 
    <B><CODE>if</CODE></B> statement and is required.

<P> <I>test_condition</I> is one of the following:
<DL>
<DT><I>string</I><DD>true if <I>string</I> is not empty
<BR><BR>
<DT><I>string1</I> = <I>string2</I><BR>
    <I>string1</I> != <I>string2</I>
<DD>Compare string1 with string 2.  If string2 has the form <I>/string/</I>
    than it is compared as a regular expression.
    Regular expressions have the same syntax as those found in the Unix
    egrep command.
<BR><BR>
<DT>( <I>test_condition</I> )<DD>true if <I>test_condition</I> is true 
<DT>! <I>test_condition</I><DD>true if <I>test_condition</I> is false
    <I>test_condition1</I> and <I>test_condition2</I> are true
<DT><I>test_condition1</I> && <I>test_condition2</I><DD>true if both
    <I>test_condition1</I> and <I>test_condition2</I> are true
<DT><I>test_condition1</I> || <I>test_condition2</I><DD>true if either
    <I>test_condition1</I> or <I>test_condition2</I> is true
</DL>

<P> <I>=</I> and </I>!=</I> bind more tightly than <I>&&</I> and <I>||</I>.
    <I>!</I> binds most tightly.  Thus, the following are equivalent:
<PRE>
    &lt;!--#if expr="$a = test1 && $b = test2" --&gt;
    &lt;!--#if expr="($a = test1) && ($b = test2)" --&gt;
</PRE>

<P> Anything that's not recognized as a variable or an operator is
    treated as a string.  Strings can also be quoted: <I>'string'</I>.
    Unquoted strings can't contain whitespace (blanks and tabs)
    because it is used to seperate tokens such as variables.  If
    multiple strings are found in a row, they are concatenated using
    blanks.  So,
<PRE>
     <I>string1    string2</I>  results in <I>string1 string2</I>
    <I>'string1    string2'</I> results in <I>string1    string2</I>
</PRE>

<P> Variable substitution is done within quoted strings.  You can put
    a dollar sign into the string using backslash quoting:
<PRE>
    &lt;!--#if expr="$a = \$test" --&gt;
</PRE>

<P> <H3>System Interaction Directives</H3></P>
<P> The <B><CODE>include</CODE></B> directive inserts the text of a
    document into the parsed document. 
<PRE>
    &lt;!--#include virtual="<I>URL</I>" --&gt;
    &lt;!--#include file="<I>path</I>" --&gt;
</PRE>
<UL>
<LI><P><CODE>virtual</CODE> gives a URL reference (which may be relative)
    to a document on the server.   Unlike the NCSA equivalent, you may
    access any url accessable on the server including CGI scripts.  You
    can use this to pass PATH_INFO or QUERY_STRING information to the
    script - which you can't do using &lt;!--#exec&nbsp;cgi&nbsp;--&gt;.
    You can also access another parsed document. </P>

<LI><P><CODE>file</CODE> gives a pathname relative to the current
    directory. ../ cannot be used in this pathname, nor can absolute paths
    be used. As above, you can send other parsed documents, but you cannot
    send CGI scripts. </P>
</UL>

<P> The <B><CODE>exec</CODE></B> directive executes a given shell
    command or CGI script  (<EM>The server to recognize and execute
    this directive</EM>).</P>
<PRE>
    &lt;!--#exec cmd="<I>command_string</I>" --&gt;
    &lt;!--#exec cgi="<I>CGI_URL</I>" --&gt;
</PRE>
<UL>
<LI><P><CODE>cmd</CODE> will execute the given string using /bin/sh. All
    of the variables defined below are defined, and can be used in the
    command.</P>

<LI><P><CODE>cgi</CODE> will execute the given virtual path to a CGI
    script and include its output. The server does not perform error
    checking to make sure your script didn't output horrible things like a
    GIF, so be careful.  It will, however, interpret any URL Location:
    header and translate it into an HTML anchor.  You cannot pass
    PATH_INFO or QUERY_STRING data this way - see
    &lt;--#include&nbsp;virtual&nbsp;--&gt;.</P>
</UL>

<HR>
<H2><A NAME="install">SSI Installation</A></H2>

<P> See the
    <A HREF="http://hoohoo.ncsa.uiuc.edu/docs/tutorials/includes.html"><!--
    -->NCSA Server Side Include Tutorial</A> and the 
    <A HREF="http://www.apache.org/docs/">APACHE Server Documentation</A> 
    for instructions on how to configure the server to support
    Server-Side includes.

<P><A HREF="ftp://pageplus.com/pub/hsf/xssi/">Retrieve xssi</A> and
    follow the directions in the README file to install.</P>

<HR>
<A NAME="notes"><H2>SSI Notes and Issues</H2>

<P> XSSI-1.2 works for Apache 1.2 and above.</P>

<P> You can view my <A HREF="test.shtml">test page</A> and its
    <A HREF="test.txt">source</A> for some examples.

<P> XSSI only works for the <A HREF="//www.apache.org/">Apache</A>
    httpd server.

<P> The following directives have been added to the 
    <A HREF="http://hoohoo.ncsa.uiuc.edu/docs/tutorials/includes.html"><!--
    -->Standard SSI</A> to create the XSSI:
<PRE>
    &lt;!--#set var="<I>variable_name</I>" value="<I>variable_value</I>"--&gt;
    &lt;!--#printenv --&gt;
    &lt;!--#if expr="<I>test_condition</I>" --&gt;
    &lt;!--#elif expr="<I>test_condition</I>" --&gt;
    &lt;!--#else --&gt;
    &lt;!--#endif --&gt;
</PRE>

<P> The only place where they may be an incompatibility with the standard
    SSI is if a tag value used a '$'.  This should only have been possible
    in a &lt;!--#exec cmd="..." --&gt; directive.

<P> Having the server parse documents is a double edged sword. It can
    be costly for heavily loaded servers to perform parsing of files
    while sending them. Further, it can be considered a security risk
    to have average users executing commands as the server's User. If
    you disable the exec option, this danger is mitigated, but the
    performance issue remains.  You should consider these items
    carefully before activating server-side includes on your server.</P>

<HR>
<H2>Acknowledgements</H2>
 <P>XSSI uses the regular expression package written by Henry Spencer,
    as modified by Karl-Johan Johnsson the author of
    <A HREF="http://www.nada.kth.se/~su95-kjo/knews.html">knews</A>.

 <P>If handling bug identified and patched by Vaughn Skinner <vaughn@solid.net>.
<HR>
<ADDRESS>
    <A HREF="/~hsf/">Howard Fear</A>
    &lt;<A HREF="mailto:hsf@pageplus.com">hsf@pageplus.com</A>&gt;
</BODY></HTML>
